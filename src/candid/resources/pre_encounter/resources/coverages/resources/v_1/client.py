# This file was auto-generated by Fern from our API Definition.

import typing
from .......core.client_wrapper import SyncClientWrapper
from .types.mutable_coverage import MutableCoverage
from .......core.request_options import RequestOptions
from .types.coverage import Coverage
from json.decoder import JSONDecodeError
from .......core.api_error import ApiError
from .......core.pydantic_utilities import parse_obj_as
from ....common.types.coverage_id import CoverageId
from .......core.jsonable_encoder import jsonable_encoder
from ....common.errors.not_found_error import NotFoundError
from ....common.types.error_base_4_xx import ErrorBase4Xx
from ....common.errors.version_conflict_error import VersionConflictError
from ....common.types.version_conflict_error_body import VersionConflictErrorBody
from ....common.types.page_token import PageToken
from .types.coverages_page import CoveragesPage
from ....common.errors.bad_request_error import BadRequestError
import datetime as dt
from .......core.datetime_utils import serialize_datetime
from .types.service_type_code import ServiceTypeCode
from .types.eligibility_check_metadata import EligibilityCheckMetadata
from .types.coverage_eligibility_check_response import CoverageEligibilityCheckResponse
from .......core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class V1Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(self, *, request: MutableCoverage, request_options: typing.Optional[RequestOptions] = None) -> Coverage:
        """
        Creates a new Coverage. A Coverage provides the high-level identifiers and descriptors of a specific insurance plan for a specific individual - typically the information you can find on an insurance card. Additionally a coverage will include detailed benefits information covered by the specific plan for the individual.

        Parameters
        ----------
        request : MutableCoverage

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Coverage

        Examples
        --------
        import datetime
        import uuid

        from candid import CandidApiClient
        from candid.resources.pre_encounter.resources.common import (
            AdditionalPayerInformation,
            Address,
            AddressUse,
            HumanName,
            NameUse,
            Period,
            Relationship,
            Sex,
        )
        from candid.resources.pre_encounter.resources.coverages.resources.v_1 import (
            CoverageBenefits,
            CoverageStatus,
            EligibilityStatus,
            InsurancePlan,
            InsuranceTypeCode,
            LatestEligibilityCheck,
            MutableCoverage,
            NetworkType,
            Subscriber,
        )

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.create(
            request=MutableCoverage(
                status=CoverageStatus.ACTIVE,
                subscriber=Subscriber(
                    name=HumanName(
                        family="string",
                        given=["string"],
                        use=NameUse.USUAL,
                        period=Period(),
                    ),
                    date_of_birth=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    biological_sex=Sex.FEMALE,
                    address=Address(
                        use=AddressUse.HOME,
                        line=["string"],
                        city="string",
                        state="string",
                        postal_code="string",
                        country="string",
                        period=Period(),
                    ),
                ),
                relationship=Relationship.SELF,
                patient="string",
                insurance_plan=InsurancePlan(
                    member_id="string",
                    payer_id="string",
                    payer_name="string",
                    additional_payer_information=AdditionalPayerInformation(),
                    group_number="string",
                    name="string",
                    plan_type=NetworkType.SELF_PAY,
                    type=InsuranceTypeCode.C_01,
                    period=Period(),
                    insurance_card_image_locator="string",
                    payer_plan_group_id=uuid.UUID(
                        "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                    ),
                ),
                verified=True,
                eligibility_checks=[],
                latest_eligibility_check=LatestEligibilityCheck(
                    check_id="string",
                    status=EligibilityStatus.ACTIVE,
                    initiated_at=datetime.datetime.fromisoformat(
                        "2024-01-15 09:30:00+00:00",
                    ),
                ),
                benefits=CoverageBenefits(),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "coverages/v1",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                Coverage,
                parse_obj_as(
                    type_=Coverage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        id: CoverageId,
        version: str,
        *,
        request: MutableCoverage,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Coverage:
        """
        Updates a Coverage. The path must contain the most recent version to prevent race conditions. Updating historic versions is not supported.

        Parameters
        ----------
        id : CoverageId

        version : str

        request : MutableCoverage

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Coverage

        Examples
        --------
        import datetime
        import uuid

        from candid import CandidApiClient
        from candid.resources.pre_encounter.resources.common import (
            AdditionalPayerInformation,
            Address,
            AddressUse,
            HumanName,
            NameUse,
            Period,
            Relationship,
            Sex,
        )
        from candid.resources.pre_encounter.resources.coverages.resources.v_1 import (
            CoverageBenefits,
            CoverageStatus,
            EligibilityStatus,
            InsurancePlan,
            InsuranceTypeCode,
            LatestEligibilityCheck,
            MutableCoverage,
            NetworkType,
            Subscriber,
        )

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.update(
            id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            version="string",
            request=MutableCoverage(
                status=CoverageStatus.ACTIVE,
                subscriber=Subscriber(
                    name=HumanName(
                        family="string",
                        given=["string"],
                        use=NameUse.USUAL,
                        period=Period(),
                    ),
                    date_of_birth=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    biological_sex=Sex.FEMALE,
                    address=Address(
                        use=AddressUse.HOME,
                        line=["string"],
                        city="string",
                        state="string",
                        postal_code="string",
                        country="string",
                        period=Period(),
                    ),
                ),
                relationship=Relationship.SELF,
                patient="string",
                insurance_plan=InsurancePlan(
                    member_id="string",
                    payer_id="string",
                    payer_name="string",
                    additional_payer_information=AdditionalPayerInformation(),
                    group_number="string",
                    name="string",
                    plan_type=NetworkType.SELF_PAY,
                    type=InsuranceTypeCode.C_01,
                    period=Period(),
                    insurance_card_image_locator="string",
                    payer_plan_group_id=uuid.UUID(
                        "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                    ),
                ),
                verified=True,
                eligibility_checks=[],
                latest_eligibility_check=LatestEligibilityCheck(
                    check_id="string",
                    status=EligibilityStatus.ACTIVE,
                    initiated_at=datetime.datetime.fromisoformat(
                        "2024-01-15 09:30:00+00:00",
                    ),
                ),
                benefits=CoverageBenefits(),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/{jsonable_encoder(version)}",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                Coverage,
                parse_obj_as(
                    type_=Coverage,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "NotFoundError":
                raise NotFoundError(
                    typing.cast(
                        ErrorBase4Xx,
                        parse_obj_as(
                            type_=ErrorBase4Xx,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "VersionConflictError":
                raise VersionConflictError(
                    typing.cast(
                        VersionConflictErrorBody,
                        parse_obj_as(
                            type_=VersionConflictErrorBody,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_multi_paginated(
        self,
        *,
        patient_id: typing.Optional[str] = None,
        payer_plan_group_id: typing.Optional[str] = None,
        page_token: typing.Optional[PageToken] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CoveragesPage:
        """
        Returns a page of Coverages based on the search criteria.

        Parameters
        ----------
        patient_id : typing.Optional[str]

        payer_plan_group_id : typing.Optional[str]

        page_token : typing.Optional[PageToken]

        limit : typing.Optional[int]
            Must be between 0 and 1000. Defaults to 100

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CoveragesPage

        Examples
        --------
        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.get_multi_paginated(
            patient_id="string",
            payer_plan_group_id="string",
            page_token="string",
            limit=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "coverages/v1/get-multi-paginated",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            params={
                "patient_id": patient_id,
                "payer_plan_group_id": payer_plan_group_id,
                "page_token": page_token,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                CoveragesPage,
                parse_obj_as(
                    type_=CoveragesPage,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequestError":
                raise BadRequestError(
                    typing.cast(
                        ErrorBase4Xx,
                        parse_obj_as(
                            type_=ErrorBase4Xx,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: CoverageId, *, request_options: typing.Optional[RequestOptions] = None) -> Coverage:
        """
        gets a specific Coverage

        Parameters
        ----------
        id : CoverageId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Coverage

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.get(
            id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                Coverage,
                parse_obj_as(
                    type_=Coverage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_history(
        self, id: CoverageId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Coverage]:
        """
        Gets a coverage along with it's full history. The return list is ordered by version ascending.

        Parameters
        ----------
        id : CoverageId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Coverage]

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.get_history(
            id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/history",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                typing.List[Coverage],
                parse_obj_as(
                    type_=typing.List[Coverage],  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "NotFoundError":
                raise NotFoundError(
                    typing.cast(
                        ErrorBase4Xx,
                        parse_obj_as(
                            type_=ErrorBase4Xx,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_multi(
        self, *, patient_id: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Coverage]:
        """
        Returns a list of Coverages based on the search criteria.

        Parameters
        ----------
        patient_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Coverage]

        Examples
        --------
        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.get_multi(
            patient_id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "coverages/v1",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            params={
                "patient_id": patient_id,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                typing.List[Coverage],
                parse_obj_as(
                    type_=typing.List[Coverage],  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def scan(
        self, *, since: dt.datetime, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Coverage]:
        """
        Scans up to 100 coverage updates. The since query parameter is inclusive, and the result list is ordered by updatedAt ascending.

        Parameters
        ----------
        since : dt.datetime

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Coverage]

        Examples
        --------
        import datetime

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.scan(
            since=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "coverages/v1/updates/scan",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            params={
                "since": serialize_datetime(since),
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                typing.List[Coverage],
                parse_obj_as(
                    type_=typing.List[Coverage],  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def check_eligibility(
        self,
        id: CoverageId,
        *,
        service_code: ServiceTypeCode,
        date_of_service: dt.date,
        npi: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EligibilityCheckMetadata:
        """
        Initiates an eligibility check. Returns the metadata of the check if successfully initiated.

        Parameters
        ----------
        id : CoverageId

        service_code : ServiceTypeCode

        date_of_service : dt.date

        npi : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EligibilityCheckMetadata

        Examples
        --------
        import datetime
        import uuid

        from candid import CandidApiClient
        from candid.resources.pre_encounter.resources.coverages.resources.v_1 import (
            ServiceTypeCode,
        )

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.check_eligibility(
            id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            service_code=ServiceTypeCode.MEDICAL_CARE,
            date_of_service=datetime.date.fromisoformat(
                "2023-01-15",
            ),
            npi="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/eligibility",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="POST",
            json={
                "service_code": service_code,
                "date_of_service": date_of_service,
                "npi": npi,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                EligibilityCheckMetadata,
                parse_obj_as(
                    type_=EligibilityCheckMetadata,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eligibility(
        self, id: CoverageId, check_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CoverageEligibilityCheckResponse:
        """
        Gets the eligibility of a patient for a specific coverage if successful.

        Parameters
        ----------
        id : CoverageId

        check_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CoverageEligibilityCheckResponse

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.pre_encounter.coverages.v_1.get_eligibility(
            id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            check_id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/eligibility/{jsonable_encoder(check_id)}",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                CoverageEligibilityCheckResponse,
                parse_obj_as(
                    type_=CoverageEligibilityCheckResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncV1Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self, *, request: MutableCoverage, request_options: typing.Optional[RequestOptions] = None
    ) -> Coverage:
        """
        Creates a new Coverage. A Coverage provides the high-level identifiers and descriptors of a specific insurance plan for a specific individual - typically the information you can find on an insurance card. Additionally a coverage will include detailed benefits information covered by the specific plan for the individual.

        Parameters
        ----------
        request : MutableCoverage

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Coverage

        Examples
        --------
        import asyncio
        import datetime
        import uuid

        from candid import AsyncCandidApiClient
        from candid.resources.pre_encounter.resources.common import (
            AdditionalPayerInformation,
            Address,
            AddressUse,
            HumanName,
            NameUse,
            Period,
            Relationship,
            Sex,
        )
        from candid.resources.pre_encounter.resources.coverages.resources.v_1 import (
            CoverageBenefits,
            CoverageStatus,
            EligibilityStatus,
            InsurancePlan,
            InsuranceTypeCode,
            LatestEligibilityCheck,
            MutableCoverage,
            NetworkType,
            Subscriber,
        )

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.create(
                request=MutableCoverage(
                    status=CoverageStatus.ACTIVE,
                    subscriber=Subscriber(
                        name=HumanName(
                            family="string",
                            given=["string"],
                            use=NameUse.USUAL,
                            period=Period(),
                        ),
                        date_of_birth=datetime.date.fromisoformat(
                            "2023-01-15",
                        ),
                        biological_sex=Sex.FEMALE,
                        address=Address(
                            use=AddressUse.HOME,
                            line=["string"],
                            city="string",
                            state="string",
                            postal_code="string",
                            country="string",
                            period=Period(),
                        ),
                    ),
                    relationship=Relationship.SELF,
                    patient="string",
                    insurance_plan=InsurancePlan(
                        member_id="string",
                        payer_id="string",
                        payer_name="string",
                        additional_payer_information=AdditionalPayerInformation(),
                        group_number="string",
                        name="string",
                        plan_type=NetworkType.SELF_PAY,
                        type=InsuranceTypeCode.C_01,
                        period=Period(),
                        insurance_card_image_locator="string",
                        payer_plan_group_id=uuid.UUID(
                            "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                        ),
                    ),
                    verified=True,
                    eligibility_checks=[],
                    latest_eligibility_check=LatestEligibilityCheck(
                        check_id="string",
                        status=EligibilityStatus.ACTIVE,
                        initiated_at=datetime.datetime.fromisoformat(
                            "2024-01-15 09:30:00+00:00",
                        ),
                    ),
                    benefits=CoverageBenefits(),
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "coverages/v1",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                Coverage,
                parse_obj_as(
                    type_=Coverage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        id: CoverageId,
        version: str,
        *,
        request: MutableCoverage,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Coverage:
        """
        Updates a Coverage. The path must contain the most recent version to prevent race conditions. Updating historic versions is not supported.

        Parameters
        ----------
        id : CoverageId

        version : str

        request : MutableCoverage

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Coverage

        Examples
        --------
        import asyncio
        import datetime
        import uuid

        from candid import AsyncCandidApiClient
        from candid.resources.pre_encounter.resources.common import (
            AdditionalPayerInformation,
            Address,
            AddressUse,
            HumanName,
            NameUse,
            Period,
            Relationship,
            Sex,
        )
        from candid.resources.pre_encounter.resources.coverages.resources.v_1 import (
            CoverageBenefits,
            CoverageStatus,
            EligibilityStatus,
            InsurancePlan,
            InsuranceTypeCode,
            LatestEligibilityCheck,
            MutableCoverage,
            NetworkType,
            Subscriber,
        )

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.update(
                id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                version="string",
                request=MutableCoverage(
                    status=CoverageStatus.ACTIVE,
                    subscriber=Subscriber(
                        name=HumanName(
                            family="string",
                            given=["string"],
                            use=NameUse.USUAL,
                            period=Period(),
                        ),
                        date_of_birth=datetime.date.fromisoformat(
                            "2023-01-15",
                        ),
                        biological_sex=Sex.FEMALE,
                        address=Address(
                            use=AddressUse.HOME,
                            line=["string"],
                            city="string",
                            state="string",
                            postal_code="string",
                            country="string",
                            period=Period(),
                        ),
                    ),
                    relationship=Relationship.SELF,
                    patient="string",
                    insurance_plan=InsurancePlan(
                        member_id="string",
                        payer_id="string",
                        payer_name="string",
                        additional_payer_information=AdditionalPayerInformation(),
                        group_number="string",
                        name="string",
                        plan_type=NetworkType.SELF_PAY,
                        type=InsuranceTypeCode.C_01,
                        period=Period(),
                        insurance_card_image_locator="string",
                        payer_plan_group_id=uuid.UUID(
                            "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                        ),
                    ),
                    verified=True,
                    eligibility_checks=[],
                    latest_eligibility_check=LatestEligibilityCheck(
                        check_id="string",
                        status=EligibilityStatus.ACTIVE,
                        initiated_at=datetime.datetime.fromisoformat(
                            "2024-01-15 09:30:00+00:00",
                        ),
                    ),
                    benefits=CoverageBenefits(),
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/{jsonable_encoder(version)}",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                Coverage,
                parse_obj_as(
                    type_=Coverage,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "NotFoundError":
                raise NotFoundError(
                    typing.cast(
                        ErrorBase4Xx,
                        parse_obj_as(
                            type_=ErrorBase4Xx,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "VersionConflictError":
                raise VersionConflictError(
                    typing.cast(
                        VersionConflictErrorBody,
                        parse_obj_as(
                            type_=VersionConflictErrorBody,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_multi_paginated(
        self,
        *,
        patient_id: typing.Optional[str] = None,
        payer_plan_group_id: typing.Optional[str] = None,
        page_token: typing.Optional[PageToken] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CoveragesPage:
        """
        Returns a page of Coverages based on the search criteria.

        Parameters
        ----------
        patient_id : typing.Optional[str]

        payer_plan_group_id : typing.Optional[str]

        page_token : typing.Optional[PageToken]

        limit : typing.Optional[int]
            Must be between 0 and 1000. Defaults to 100

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CoveragesPage

        Examples
        --------
        import asyncio

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.get_multi_paginated(
                patient_id="string",
                payer_plan_group_id="string",
                page_token="string",
                limit=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "coverages/v1/get-multi-paginated",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            params={
                "patient_id": patient_id,
                "payer_plan_group_id": payer_plan_group_id,
                "page_token": page_token,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                CoveragesPage,
                parse_obj_as(
                    type_=CoveragesPage,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequestError":
                raise BadRequestError(
                    typing.cast(
                        ErrorBase4Xx,
                        parse_obj_as(
                            type_=ErrorBase4Xx,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, id: CoverageId, *, request_options: typing.Optional[RequestOptions] = None) -> Coverage:
        """
        gets a specific Coverage

        Parameters
        ----------
        id : CoverageId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Coverage

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.get(
                id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                Coverage,
                parse_obj_as(
                    type_=Coverage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_history(
        self, id: CoverageId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Coverage]:
        """
        Gets a coverage along with it's full history. The return list is ordered by version ascending.

        Parameters
        ----------
        id : CoverageId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Coverage]

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.get_history(
                id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/history",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                typing.List[Coverage],
                parse_obj_as(
                    type_=typing.List[Coverage],  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "NotFoundError":
                raise NotFoundError(
                    typing.cast(
                        ErrorBase4Xx,
                        parse_obj_as(
                            type_=ErrorBase4Xx,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_multi(
        self, *, patient_id: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Coverage]:
        """
        Returns a list of Coverages based on the search criteria.

        Parameters
        ----------
        patient_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Coverage]

        Examples
        --------
        import asyncio

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.get_multi(
                patient_id="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "coverages/v1",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            params={
                "patient_id": patient_id,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                typing.List[Coverage],
                parse_obj_as(
                    type_=typing.List[Coverage],  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def scan(
        self, *, since: dt.datetime, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Coverage]:
        """
        Scans up to 100 coverage updates. The since query parameter is inclusive, and the result list is ordered by updatedAt ascending.

        Parameters
        ----------
        since : dt.datetime

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Coverage]

        Examples
        --------
        import asyncio
        import datetime

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.scan(
                since=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "coverages/v1/updates/scan",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            params={
                "since": serialize_datetime(since),
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                typing.List[Coverage],
                parse_obj_as(
                    type_=typing.List[Coverage],  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def check_eligibility(
        self,
        id: CoverageId,
        *,
        service_code: ServiceTypeCode,
        date_of_service: dt.date,
        npi: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EligibilityCheckMetadata:
        """
        Initiates an eligibility check. Returns the metadata of the check if successfully initiated.

        Parameters
        ----------
        id : CoverageId

        service_code : ServiceTypeCode

        date_of_service : dt.date

        npi : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EligibilityCheckMetadata

        Examples
        --------
        import asyncio
        import datetime
        import uuid

        from candid import AsyncCandidApiClient
        from candid.resources.pre_encounter.resources.coverages.resources.v_1 import (
            ServiceTypeCode,
        )

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.check_eligibility(
                id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                service_code=ServiceTypeCode.MEDICAL_CARE,
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                npi="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/eligibility",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="POST",
            json={
                "service_code": service_code,
                "date_of_service": date_of_service,
                "npi": npi,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                EligibilityCheckMetadata,
                parse_obj_as(
                    type_=EligibilityCheckMetadata,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eligibility(
        self, id: CoverageId, check_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CoverageEligibilityCheckResponse:
        """
        Gets the eligibility of a patient for a specific coverage if successful.

        Parameters
        ----------
        id : CoverageId

        check_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CoverageEligibilityCheckResponse

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.pre_encounter.coverages.v_1.get_eligibility(
                id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                check_id="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"coverages/v1/{jsonable_encoder(id)}/eligibility/{jsonable_encoder(check_id)}",
            base_url=self._client_wrapper.get_environment().pre_encounter,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                CoverageEligibilityCheckResponse,
                parse_obj_as(
                    type_=CoverageEligibilityCheckResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)
