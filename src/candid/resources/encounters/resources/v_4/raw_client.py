# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from .....core.api_error import ApiError
from .....core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .....core.datetime_utils import serialize_datetime
from .....core.http_response import AsyncHttpResponse, HttpResponse
from .....core.jsonable_encoder import jsonable_encoder
from .....core.pydantic_utilities import parse_obj_as
from .....core.request_options import RequestOptions
from ....claims.types.claim_status import ClaimStatus
from ....commons.errors.entity_not_found_error import EntityNotFoundError
from ....commons.errors.http_request_validation_error import HttpRequestValidationError
from ....commons.errors.http_request_validations_error import HttpRequestValidationsError
from ....commons.errors.unauthorized_error import UnauthorizedError
from ....commons.errors.unprocessable_entity_error import UnprocessableEntityError
from ....commons.types.encounter_external_id import EncounterExternalId
from ....commons.types.encounter_id import EncounterId
from ....commons.types.entity_not_found_error_message import EntityNotFoundErrorMessage
from ....commons.types.page_token import PageToken
from ....commons.types.request_validation_error import RequestValidationError
from ....commons.types.unauthorized_error_message import UnauthorizedErrorMessage
from ....commons.types.unprocessable_entity_error_message import UnprocessableEntityErrorMessage
from ....commons.types.work_queue_id import WorkQueueId
from ....tags.types.tag_id import TagId
from .errors.cash_pay_payer_error import CashPayPayerError
from .errors.encounter_external_id_uniqueness_error import EncounterExternalIdUniquenessError
from .errors.encounter_guarantor_missing_contact_info_error import EncounterGuarantorMissingContactInfoError
from .errors.encounter_patient_control_number_uniqueness_error import EncounterPatientControlNumberUniquenessError
from .errors.encounter_rendering_or_attending_provider_required import EncounterRenderingOrAttendingProviderRequired
from .errors.invalid_tag_names_error import InvalidTagNamesError
from .errors.payer_plan_group_payer_does_not_match_insurance_card_http_error import (
    PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError,
)
from .errors.schema_instance_validation_http_failure import SchemaInstanceValidationHttpFailure
from .types.billable_status_type import BillableStatusType
from .types.cash_pay_payer_error_message import CashPayPayerErrorMessage
from .types.encounter import Encounter
from .types.encounter_create import EncounterCreate
from .types.encounter_create_from_pre_encounter import EncounterCreateFromPreEncounter
from .types.encounter_external_id_uniqueness_error_type import EncounterExternalIdUniquenessErrorType
from .types.encounter_guarantor_missing_contact_info_error_type import EncounterGuarantorMissingContactInfoErrorType
from .types.encounter_owner_of_next_action_type import EncounterOwnerOfNextActionType
from .types.encounter_page import EncounterPage
from .types.encounter_patient_control_number_uniqueness_error_type import (
    EncounterPatientControlNumberUniquenessErrorType,
)
from .types.encounter_rendering_or_attending_provider_required_error import (
    EncounterRenderingOrAttendingProviderRequiredError,
)
from .types.encounter_sort_options import EncounterSortOptions
from .types.encounter_update import EncounterUpdate
from .types.invalid_tag_names_error_type import InvalidTagNamesErrorType
from .types.payer_plan_group_payer_does_not_match_insurance_card_error import (
    PayerPlanGroupPayerDoesNotMatchInsuranceCardError,
)
from .types.responsible_party_type import ResponsiblePartyType
from .types.schema_instance_validation_failure import SchemaInstanceValidationFailure

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawV4Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        claim_status: typing.Optional[ClaimStatus] = None,
        sort: typing.Optional[EncounterSortOptions] = None,
        page_token: typing.Optional[PageToken] = None,
        date_of_service_min: typing.Optional[dt.date] = None,
        date_of_service_max: typing.Optional[dt.date] = None,
        primary_payer_names: typing.Optional[str] = None,
        search_term: typing.Optional[str] = None,
        external_id: typing.Optional[EncounterExternalId] = None,
        diagnoses_updated_since: typing.Optional[dt.datetime] = None,
        tag_ids: typing.Optional[typing.Union[TagId, typing.Sequence[TagId]]] = None,
        work_queue_id: typing.Optional[WorkQueueId] = None,
        billable_status: typing.Optional[BillableStatusType] = None,
        responsible_party: typing.Optional[ResponsiblePartyType] = None,
        owner_of_next_action: typing.Optional[EncounterOwnerOfNextActionType] = None,
        patient_external_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EncounterPage]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        claim_status : typing.Optional[ClaimStatus]
            Indicates the current status of an insurance claim within the billing process.

        sort : typing.Optional[EncounterSortOptions]
            Defaults to created_at:desc.

        page_token : typing.Optional[PageToken]

        date_of_service_min : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-25.

        date_of_service_max : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-25.

        primary_payer_names : typing.Optional[str]
            Comma delimited string.

        search_term : typing.Optional[str]
            Filter by any of the following fields: encounter_id, claim_id, patient external_id,
            patient date of birth, patient first name, patient last name,
            or encounter external id.

        external_id : typing.Optional[EncounterExternalId]
            Filter to an exact match on encounter external_id, if one exists.

        diagnoses_updated_since : typing.Optional[dt.datetime]
            ISO 8601 timestamp; ideally in UTC (although not required): 2019-08-24T14:15:22Z.

        tag_ids : typing.Optional[typing.Union[TagId, typing.Sequence[TagId]]]
            Filter by name of tags on encounters.

        work_queue_id : typing.Optional[WorkQueueId]

        billable_status : typing.Optional[BillableStatusType]
            Defines if the Encounter is to be billed by Candid to the responsible_party. Examples for when this should be set to NOT_BILLABLE include if the Encounter has not occurred yet or if there is no intention of ever billing the responsible_party.

        responsible_party : typing.Optional[ResponsiblePartyType]
            Defines the party to be billed with the initial balance owed on the claim. Use SELF_PAY if you intend to bill self pay/cash pay.

        owner_of_next_action : typing.Optional[EncounterOwnerOfNextActionType]
            The party who is responsible for taking the next action on an Encounter, as defined by ownership of open Tasks.

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EncounterPage]
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/encounters/v4",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "claim_status": claim_status,
                "sort": sort,
                "page_token": page_token,
                "date_of_service_min": str(date_of_service_min) if date_of_service_min is not None else None,
                "date_of_service_max": str(date_of_service_max) if date_of_service_max is not None else None,
                "primary_payer_names": primary_payer_names,
                "search_term": search_term,
                "external_id": external_id,
                "diagnoses_updated_since": serialize_datetime(diagnoses_updated_since)
                if diagnoses_updated_since is not None
                else None,
                "tag_ids": tag_ids,
                "work_queue_id": work_queue_id,
                "billable_status": billable_status,
                "responsible_party": responsible_party,
                "owner_of_next_action": owner_of_next_action,
                "patient_external_id": patient_external_id,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                EncounterPage,
                parse_obj_as(
                    type_=EncounterPage,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self, encounter_id: EncounterId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Encounter]:
        """
        Parameters
        ----------
        encounter_id : EncounterId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Encounter]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/encounters/v4/{jsonable_encoder(encounter_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self, *, request: EncounterCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Encounter]:
        """
        Parameters
        ----------
        request : EncounterCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Encounter]
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/encounters/v4",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EncounterExternalIdUniquenessError":
                raise EncounterExternalIdUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterExternalIdUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterExternalIdUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterPatientControlNumberUniquenessError":
                raise EncounterPatientControlNumberUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterPatientControlNumberUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterPatientControlNumberUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterGuarantorMissingContactInfoError":
                raise EncounterGuarantorMissingContactInfoError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterGuarantorMissingContactInfoErrorType,
                        parse_obj_as(
                            type_=EncounterGuarantorMissingContactInfoErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "CashPayPayerError":
                raise CashPayPayerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        CashPayPayerErrorMessage,
                        parse_obj_as(
                            type_=CashPayPayerErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InvalidTagNamesError":
                raise InvalidTagNamesError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        InvalidTagNamesErrorType,
                        parse_obj_as(
                            type_=InvalidTagNamesErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationError":
                raise HttpRequestValidationError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RequestValidationError,
                        parse_obj_as(
                            type_=RequestValidationError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError":
                raise PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayerPlanGroupPayerDoesNotMatchInsuranceCardError,
                        parse_obj_as(
                            type_=PayerPlanGroupPayerDoesNotMatchInsuranceCardError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterRenderingOrAttendingProviderRequired":
                raise EncounterRenderingOrAttendingProviderRequired(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterRenderingOrAttendingProviderRequiredError,
                        parse_obj_as(
                            type_=EncounterRenderingOrAttendingProviderRequiredError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_from_pre_encounter_patient(
        self, *, request: EncounterCreateFromPreEncounter, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Encounter]:
        """
        Create an encounter from a pre-encounter patient and appointment. This endpoint is intended to be used by consumers who are managing
        patients and appointments in the pre-encounter service and is currently under development. Consumers who are not taking advantage
        of the pre-encounter service should use the standard create endpoint.

        The endpoint will create an encounter from the provided fields, pulling information from the provided patient and appointment objects
        where applicable. In particular, the following fields are populated from the patient and appointment objects:
          - Patient
          - Referring Provider
          - Subscriber Primary
          - Subscriber Secondary
          - Referral Number
          - Responsible Party
          - Guarantor

        Utilizing this endpoint opts you into automatic updating of the encounter when the patient or appointment is updated, assuming the
        encounter has not already been submitted or adjudicated.

        Parameters
        ----------
        request : EncounterCreateFromPreEncounter

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Encounter]
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/encounters/v4/create-from-pre-encounter",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EncounterExternalIdUniquenessError":
                raise EncounterExternalIdUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterExternalIdUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterExternalIdUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterPatientControlNumberUniquenessError":
                raise EncounterPatientControlNumberUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterPatientControlNumberUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterPatientControlNumberUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationError":
                raise HttpRequestValidationError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RequestValidationError,
                        parse_obj_as(
                            type_=RequestValidationError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError":
                raise PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayerPlanGroupPayerDoesNotMatchInsuranceCardError,
                        parse_obj_as(
                            type_=PayerPlanGroupPayerDoesNotMatchInsuranceCardError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        encounter_id: EncounterId,
        *,
        request: EncounterUpdate,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Encounter]:
        """
        Parameters
        ----------
        encounter_id : EncounterId

        request : EncounterUpdate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Encounter]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/encounters/v4/{jsonable_encoder(encounter_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EncounterExternalIdUniquenessError":
                raise EncounterExternalIdUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterExternalIdUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterExternalIdUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnprocessableEntityErrorMessage,
                        parse_obj_as(
                            type_=UnprocessableEntityErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InvalidTagNamesError":
                raise InvalidTagNamesError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        InvalidTagNamesErrorType,
                        parse_obj_as(
                            type_=InvalidTagNamesErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError":
                raise PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayerPlanGroupPayerDoesNotMatchInsuranceCardError,
                        parse_obj_as(
                            type_=PayerPlanGroupPayerDoesNotMatchInsuranceCardError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawV4Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        claim_status: typing.Optional[ClaimStatus] = None,
        sort: typing.Optional[EncounterSortOptions] = None,
        page_token: typing.Optional[PageToken] = None,
        date_of_service_min: typing.Optional[dt.date] = None,
        date_of_service_max: typing.Optional[dt.date] = None,
        primary_payer_names: typing.Optional[str] = None,
        search_term: typing.Optional[str] = None,
        external_id: typing.Optional[EncounterExternalId] = None,
        diagnoses_updated_since: typing.Optional[dt.datetime] = None,
        tag_ids: typing.Optional[typing.Union[TagId, typing.Sequence[TagId]]] = None,
        work_queue_id: typing.Optional[WorkQueueId] = None,
        billable_status: typing.Optional[BillableStatusType] = None,
        responsible_party: typing.Optional[ResponsiblePartyType] = None,
        owner_of_next_action: typing.Optional[EncounterOwnerOfNextActionType] = None,
        patient_external_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EncounterPage]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        claim_status : typing.Optional[ClaimStatus]
            Indicates the current status of an insurance claim within the billing process.

        sort : typing.Optional[EncounterSortOptions]
            Defaults to created_at:desc.

        page_token : typing.Optional[PageToken]

        date_of_service_min : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-25.

        date_of_service_max : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-25.

        primary_payer_names : typing.Optional[str]
            Comma delimited string.

        search_term : typing.Optional[str]
            Filter by any of the following fields: encounter_id, claim_id, patient external_id,
            patient date of birth, patient first name, patient last name,
            or encounter external id.

        external_id : typing.Optional[EncounterExternalId]
            Filter to an exact match on encounter external_id, if one exists.

        diagnoses_updated_since : typing.Optional[dt.datetime]
            ISO 8601 timestamp; ideally in UTC (although not required): 2019-08-24T14:15:22Z.

        tag_ids : typing.Optional[typing.Union[TagId, typing.Sequence[TagId]]]
            Filter by name of tags on encounters.

        work_queue_id : typing.Optional[WorkQueueId]

        billable_status : typing.Optional[BillableStatusType]
            Defines if the Encounter is to be billed by Candid to the responsible_party. Examples for when this should be set to NOT_BILLABLE include if the Encounter has not occurred yet or if there is no intention of ever billing the responsible_party.

        responsible_party : typing.Optional[ResponsiblePartyType]
            Defines the party to be billed with the initial balance owed on the claim. Use SELF_PAY if you intend to bill self pay/cash pay.

        owner_of_next_action : typing.Optional[EncounterOwnerOfNextActionType]
            The party who is responsible for taking the next action on an Encounter, as defined by ownership of open Tasks.

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EncounterPage]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/encounters/v4",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "claim_status": claim_status,
                "sort": sort,
                "page_token": page_token,
                "date_of_service_min": str(date_of_service_min) if date_of_service_min is not None else None,
                "date_of_service_max": str(date_of_service_max) if date_of_service_max is not None else None,
                "primary_payer_names": primary_payer_names,
                "search_term": search_term,
                "external_id": external_id,
                "diagnoses_updated_since": serialize_datetime(diagnoses_updated_since)
                if diagnoses_updated_since is not None
                else None,
                "tag_ids": tag_ids,
                "work_queue_id": work_queue_id,
                "billable_status": billable_status,
                "responsible_party": responsible_party,
                "owner_of_next_action": owner_of_next_action,
                "patient_external_id": patient_external_id,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                EncounterPage,
                parse_obj_as(
                    type_=EncounterPage,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, encounter_id: EncounterId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Encounter]:
        """
        Parameters
        ----------
        encounter_id : EncounterId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Encounter]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/encounters/v4/{jsonable_encoder(encounter_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self, *, request: EncounterCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Encounter]:
        """
        Parameters
        ----------
        request : EncounterCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Encounter]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/encounters/v4",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EncounterExternalIdUniquenessError":
                raise EncounterExternalIdUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterExternalIdUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterExternalIdUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterPatientControlNumberUniquenessError":
                raise EncounterPatientControlNumberUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterPatientControlNumberUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterPatientControlNumberUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterGuarantorMissingContactInfoError":
                raise EncounterGuarantorMissingContactInfoError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterGuarantorMissingContactInfoErrorType,
                        parse_obj_as(
                            type_=EncounterGuarantorMissingContactInfoErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "CashPayPayerError":
                raise CashPayPayerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        CashPayPayerErrorMessage,
                        parse_obj_as(
                            type_=CashPayPayerErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InvalidTagNamesError":
                raise InvalidTagNamesError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        InvalidTagNamesErrorType,
                        parse_obj_as(
                            type_=InvalidTagNamesErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationError":
                raise HttpRequestValidationError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RequestValidationError,
                        parse_obj_as(
                            type_=RequestValidationError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError":
                raise PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayerPlanGroupPayerDoesNotMatchInsuranceCardError,
                        parse_obj_as(
                            type_=PayerPlanGroupPayerDoesNotMatchInsuranceCardError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterRenderingOrAttendingProviderRequired":
                raise EncounterRenderingOrAttendingProviderRequired(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterRenderingOrAttendingProviderRequiredError,
                        parse_obj_as(
                            type_=EncounterRenderingOrAttendingProviderRequiredError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_from_pre_encounter_patient(
        self, *, request: EncounterCreateFromPreEncounter, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Encounter]:
        """
        Create an encounter from a pre-encounter patient and appointment. This endpoint is intended to be used by consumers who are managing
        patients and appointments in the pre-encounter service and is currently under development. Consumers who are not taking advantage
        of the pre-encounter service should use the standard create endpoint.

        The endpoint will create an encounter from the provided fields, pulling information from the provided patient and appointment objects
        where applicable. In particular, the following fields are populated from the patient and appointment objects:
          - Patient
          - Referring Provider
          - Subscriber Primary
          - Subscriber Secondary
          - Referral Number
          - Responsible Party
          - Guarantor

        Utilizing this endpoint opts you into automatic updating of the encounter when the patient or appointment is updated, assuming the
        encounter has not already been submitted or adjudicated.

        Parameters
        ----------
        request : EncounterCreateFromPreEncounter

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Encounter]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/encounters/v4/create-from-pre-encounter",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EncounterExternalIdUniquenessError":
                raise EncounterExternalIdUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterExternalIdUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterExternalIdUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EncounterPatientControlNumberUniquenessError":
                raise EncounterPatientControlNumberUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterPatientControlNumberUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterPatientControlNumberUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationError":
                raise HttpRequestValidationError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RequestValidationError,
                        parse_obj_as(
                            type_=RequestValidationError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError":
                raise PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayerPlanGroupPayerDoesNotMatchInsuranceCardError,
                        parse_obj_as(
                            type_=PayerPlanGroupPayerDoesNotMatchInsuranceCardError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        encounter_id: EncounterId,
        *,
        request: EncounterUpdate,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Encounter]:
        """
        Parameters
        ----------
        encounter_id : EncounterId

        request : EncounterUpdate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Encounter]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/encounters/v4/{jsonable_encoder(encounter_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                Encounter,
                parse_obj_as(
                    type_=Encounter,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EncounterExternalIdUniquenessError":
                raise EncounterExternalIdUniquenessError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EncounterExternalIdUniquenessErrorType,
                        parse_obj_as(
                            type_=EncounterExternalIdUniquenessErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        UnprocessableEntityErrorMessage,
                        parse_obj_as(
                            type_=UnprocessableEntityErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InvalidTagNamesError":
                raise InvalidTagNamesError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        InvalidTagNamesErrorType,
                        parse_obj_as(
                            type_=InvalidTagNamesErrorType,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError":
                raise PayerPlanGroupPayerDoesNotMatchInsuranceCardHttpError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayerPlanGroupPayerDoesNotMatchInsuranceCardError,
                        parse_obj_as(
                            type_=PayerPlanGroupPayerDoesNotMatchInsuranceCardError,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
