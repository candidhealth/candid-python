# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ......core.datetime_utils import serialize_datetime
from ......core.pydantic_utilities import deep_union_pydantic_dicts
from .....commons.types.billing_provider_commercial_license_type import BillingProviderCommercialLicenseType
from .....commons.types.street_address_long_zip import StreetAddressLongZip
from .encounter_provider_base import EncounterProviderBase


class BillingProviderUpdate(EncounterProviderBase):
    """
    The billing provider is the provider or business entity submitting the claim.
    Billing provider may be, but is not necessarily, the same person/NPI as the rendering provider.
    From a payer's perspective, this represents the person or entity being reimbursed.
    When a contract exists with the target payer, the billing provider should be the entity contracted with the payer.
    In some circumstances, this will be an individual provider. In that case, submit that provider's NPI and the
    tax ID (TIN) that the provider gave to the payer during contracting.
    In other cases, the billing entity will be a medical group. If so, submit the group NPI and the group's tax ID.
    Box 33 on the CMS-1500 claim form.
    """

    address: typing.Optional[StreetAddressLongZip] = None
    tax_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    If the provider has a contract with insurance, this must be the same tax ID given to the payer on an IRS W-9 form completed during contracting.
    """

    npi: typing.Optional[str] = None
    taxonomy_code: typing.Optional[str] = None
    provider_commercial_license_type: typing.Optional[BillingProviderCommercialLicenseType] = pydantic.Field(
        default=None
    )
    """
    837i Loop2010BB G2
    Provider Commercial Number
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        allow_population_by_field_name = True
        populate_by_name = True
        extra = pydantic.Extra.allow
        json_encoders = {dt.datetime: serialize_datetime}
