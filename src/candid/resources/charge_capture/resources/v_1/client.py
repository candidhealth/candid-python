# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from .....core.api_error import ApiError
from .....core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .....core.jsonable_encoder import jsonable_encoder
from .....core.pydantic_utilities import pydantic_v1
from .....core.request_options import RequestOptions
from ....commons.errors.entity_not_found_error import EntityNotFoundError
from ....commons.errors.http_request_validations_error import HttpRequestValidationsError
from ....commons.errors.unauthorized_error import UnauthorizedError
from ....commons.errors.unprocessable_entity_error import UnprocessableEntityError
from ....commons.types.charge_capture_id import ChargeCaptureId
from ....commons.types.entity_not_found_error_message import EntityNotFoundErrorMessage
from ....commons.types.page_token import PageToken
from ....commons.types.request_validation_error import RequestValidationError
from ....commons.types.unauthorized_error_message import UnauthorizedErrorMessage
from ....commons.types.unprocessable_entity_error_message import UnprocessableEntityErrorMessage
from ....encounters.resources.v_4.errors.schema_instance_validation_http_failure import (
    SchemaInstanceValidationHttpFailure,
)
from ....encounters.resources.v_4.types.schema_instance_validation_failure import SchemaInstanceValidationFailure
from .types.charge_capture import ChargeCapture
from .types.charge_capture_data import ChargeCaptureData
from .types.charge_capture_page import ChargeCapturePage
from .types.charge_capture_status import ChargeCaptureStatus

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class V1Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        *,
        data: ChargeCaptureData,
        charge_external_id: str,
        patient_external_id: str,
        status: ChargeCaptureStatus,
        ehr_source_url: typing.Optional[str] = OMIT,
        date_of_service: typing.Optional[dt.date] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        data : ChargeCaptureData
            Charge Capture data contains all the fields needed to create an encounter, but listed as optional. Candid will use this data when attempting to bundle multiple Charge Captures into a single encounter.


        charge_external_id : str
            A client-specified unique ID to associate with this encounter; for example, your internal encounter ID or a Dr. Chrono encounter ID. This field should not contain PHI.


        patient_external_id : str
            The patient ID from the external EMR platform for the patient

        status : ChargeCaptureStatus
            the status of the charge capture

        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page). Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import datetime

        from candid import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EncounterServiceFacilityUpdate,
            FacilityTypeCode,
            Gender,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            PatientUpdate,
            State,
            StreetAddressLongZip,
            SubscriberCreate,
        )
        from candid.client import CandidApiClient
        from candid.resources.charge_capture.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.encounter_providers.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.v_4 import (
            BillableStatusType,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.v_1 import GuarantorUpdate
        from candid.resources.insurance_cards.v_2 import InsuranceCardCreate

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.create(
            data=ChargeCaptureData(
                diagnoses=[],
                interventions=[],
                external_claim_submission=ExternalClaimSubmissionCreate(
                    claim_created_at=datetime.datetime.fromisoformat(
                        "2023-01-01 12:00:00+00:00",
                    ),
                    patient_control_number="PATIENT_CONTROL_NUMBER",
                    submission_records=[
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-01 13:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                        ),
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-04 12:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.PAPER,
                        ),
                    ],
                ),
                service_lines=[],
                patient_histories=[],
                billing_notes=[],
                benefits_assigned_to_provider=True,
                prior_authorization_number="string",
                external_id="string",
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                tag_ids=[],
                clinical_notes=[],
                pay_to_address=StreetAddressLongZip(
                    address_1="123 Main St",
                    address_2="Apt 1",
                    city="New York",
                    state=State.NY,
                    zip_code="10001",
                    zip_plus_four_code="1234",
                ),
                billable_status=BillableStatusType.BILLABLE,
                responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                provider_accepts_assignment=True,
                synchronicity=SynchronicityType.SYNCHRONOUS,
                place_of_service_code=FacilityTypeCode.PHARMACY,
                appointment_type="string",
                end_date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                subscriber_primary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                subscriber_secondary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                additional_information="string",
                service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                admission_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                discharge_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                last_menstrual_period_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                delay_reason_code=DelayReasonCode.C_1,
                patient=PatientUpdate(),
                patient_authorized_release=True,
                schema_instances=[],
                vitals=VitalsUpdate(
                    height_in=70,
                    weight_lbs=165,
                    blood_pressure_systolic_mmhg=115,
                    blood_pressure_diastolic_mmhg=85,
                    body_temperature_f=98.0,
                    hemoglobin_gdl=15.1,
                    hematocrit_pct=51.2,
                ),
                existing_medications=[],
                rendering_provider=RenderingProviderUpdate(),
                service_facility=EncounterServiceFacilityUpdate(
                    organization_name="Test Organization",
                    address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                ),
                guarantor=GuarantorUpdate(),
                billing_provider=BillingProviderUpdate(),
                supervising_provider=SupervisingProviderUpdate(),
                referring_provider=ReferringProviderUpdate(),
                initial_referring_provider=InitialReferringProviderUpdate(),
                referral_number="string",
            ),
            charge_external_id="string",
            ehr_source_url="string",
            date_of_service=datetime.date.fromisoformat(
                "2023-01-15",
            ),
            patient_external_id="string",
            status=ChargeCaptureStatus.PLANNED,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "date_of_service": date_of_service,
                "patient_external_id": patient_external_id,
                "status": status,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapture, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic_v1.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    pydantic_v1.parse_obj_as(UnauthorizedErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    pydantic_v1.parse_obj_as(typing.List[RequestValidationError], _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    pydantic_v1.parse_obj_as(SchemaInstanceValidationFailure, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(UnprocessableEntityErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import uuid

        from candid.client import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.delete(
            charge_capture_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic_v1.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    pydantic_v1.parse_obj_as(UnauthorizedErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        charge_capture_id: ChargeCaptureId,
        *,
        data: typing.Optional[ChargeCaptureData] = OMIT,
        charge_external_id: typing.Optional[str] = OMIT,
        ehr_source_url: typing.Optional[str] = OMIT,
        patient_external_id: typing.Optional[str] = OMIT,
        status: typing.Optional[ChargeCaptureStatus] = OMIT,
        date_of_service: typing.Optional[dt.date] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        data : typing.Optional[ChargeCaptureData]

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.


        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page).
            Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge capture

        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import datetime
        import uuid

        from candid import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EncounterServiceFacilityUpdate,
            FacilityTypeCode,
            Gender,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            PatientUpdate,
            State,
            StreetAddressLongZip,
            SubscriberCreate,
        )
        from candid.client import CandidApiClient
        from candid.resources.charge_capture.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.encounter_providers.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.v_4 import (
            BillableStatusType,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.v_1 import GuarantorUpdate
        from candid.resources.insurance_cards.v_2 import InsuranceCardCreate

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.update(
            charge_capture_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            data=ChargeCaptureData(
                diagnoses=[],
                interventions=[],
                external_claim_submission=ExternalClaimSubmissionCreate(
                    claim_created_at=datetime.datetime.fromisoformat(
                        "2023-01-01 12:00:00+00:00",
                    ),
                    patient_control_number="PATIENT_CONTROL_NUMBER",
                    submission_records=[
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-01 13:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                        ),
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-04 12:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.PAPER,
                        ),
                    ],
                ),
                service_lines=[],
                patient_histories=[],
                billing_notes=[],
                benefits_assigned_to_provider=True,
                prior_authorization_number="string",
                external_id="string",
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                tag_ids=[],
                clinical_notes=[],
                pay_to_address=StreetAddressLongZip(
                    address_1="123 Main St",
                    address_2="Apt 1",
                    city="New York",
                    state=State.NY,
                    zip_code="10001",
                    zip_plus_four_code="1234",
                ),
                billable_status=BillableStatusType.BILLABLE,
                responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                provider_accepts_assignment=True,
                synchronicity=SynchronicityType.SYNCHRONOUS,
                place_of_service_code=FacilityTypeCode.PHARMACY,
                appointment_type="string",
                end_date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                subscriber_primary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                subscriber_secondary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                additional_information="string",
                service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                admission_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                discharge_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                last_menstrual_period_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                delay_reason_code=DelayReasonCode.C_1,
                patient=PatientUpdate(),
                patient_authorized_release=True,
                schema_instances=[],
                vitals=VitalsUpdate(
                    height_in=70,
                    weight_lbs=165,
                    blood_pressure_systolic_mmhg=115,
                    blood_pressure_diastolic_mmhg=85,
                    body_temperature_f=98.0,
                    hemoglobin_gdl=15.1,
                    hematocrit_pct=51.2,
                ),
                existing_medications=[],
                rendering_provider=RenderingProviderUpdate(),
                service_facility=EncounterServiceFacilityUpdate(
                    organization_name="Test Organization",
                    address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                ),
                guarantor=GuarantorUpdate(),
                billing_provider=BillingProviderUpdate(),
                supervising_provider=SupervisingProviderUpdate(),
                referring_provider=ReferringProviderUpdate(),
                initial_referring_provider=InitialReferringProviderUpdate(),
                referral_number="string",
            ),
            charge_external_id="string",
            ehr_source_url="string",
            patient_external_id="string",
            status=ChargeCaptureStatus.PLANNED,
            date_of_service=datetime.date.fromisoformat(
                "2023-01-15",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "patient_external_id": patient_external_id,
                "status": status,
                "date_of_service": date_of_service,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapture, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic_v1.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    pydantic_v1.parse_obj_as(UnauthorizedErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    pydantic_v1.parse_obj_as(typing.List[RequestValidationError], _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    pydantic_v1.parse_obj_as(SchemaInstanceValidationFailure, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(UnprocessableEntityErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import uuid

        from candid.client import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.get(
            charge_capture_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapture, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        page_token: typing.Optional[PageToken] = None,
        patient_external_id: typing.Optional[str] = None,
        status: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id: typing.Optional[str] = None,
        date_of_service: typing.Optional[dt.date] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapturePage:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        page_token : typing.Optional[PageToken]

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge captures

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapturePage

        Examples
        --------
        import datetime

        from candid.client import CandidApiClient
        from candid.resources.charge_capture.v_1 import ChargeCaptureStatus

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.get_all(
            limit=1,
            page_token="eyJ0b2tlbiI6IjEiLCJwYWdlX3Rva2VuIjoiMiJ9",
            patient_external_id="string",
            status=ChargeCaptureStatus.PLANNED,
            charge_external_id="string",
            date_of_service=datetime.date.fromisoformat(
                "2023-01-15",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "page_token": page_token,
                "patient_external_id": patient_external_id,
                "status": status,
                "charge_external_id": charge_external_id,
                "date_of_service": str(date_of_service) if date_of_service is not None else None,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapturePage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncV1Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        *,
        data: ChargeCaptureData,
        charge_external_id: str,
        patient_external_id: str,
        status: ChargeCaptureStatus,
        ehr_source_url: typing.Optional[str] = OMIT,
        date_of_service: typing.Optional[dt.date] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        data : ChargeCaptureData
            Charge Capture data contains all the fields needed to create an encounter, but listed as optional. Candid will use this data when attempting to bundle multiple Charge Captures into a single encounter.


        charge_external_id : str
            A client-specified unique ID to associate with this encounter; for example, your internal encounter ID or a Dr. Chrono encounter ID. This field should not contain PHI.


        patient_external_id : str
            The patient ID from the external EMR platform for the patient

        status : ChargeCaptureStatus
            the status of the charge capture

        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page). Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import asyncio
        import datetime

        from candid import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EncounterServiceFacilityUpdate,
            FacilityTypeCode,
            Gender,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            PatientUpdate,
            State,
            StreetAddressLongZip,
            SubscriberCreate,
        )
        from candid.client import AsyncCandidApiClient
        from candid.resources.charge_capture.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.encounter_providers.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.v_4 import (
            BillableStatusType,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.v_1 import GuarantorUpdate
        from candid.resources.insurance_cards.v_2 import InsuranceCardCreate

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.create(
                data=ChargeCaptureData(
                    diagnoses=[],
                    interventions=[],
                    external_claim_submission=ExternalClaimSubmissionCreate(
                        claim_created_at=datetime.datetime.fromisoformat(
                            "2023-01-01 12:00:00+00:00",
                        ),
                        patient_control_number="PATIENT_CONTROL_NUMBER",
                        submission_records=[
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-01 13:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                            ),
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-04 12:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.PAPER,
                            ),
                        ],
                    ),
                    service_lines=[],
                    patient_histories=[],
                    billing_notes=[],
                    benefits_assigned_to_provider=True,
                    prior_authorization_number="string",
                    external_id="string",
                    date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    tag_ids=[],
                    clinical_notes=[],
                    pay_to_address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                    billable_status=BillableStatusType.BILLABLE,
                    responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                    provider_accepts_assignment=True,
                    synchronicity=SynchronicityType.SYNCHRONOUS,
                    place_of_service_code=FacilityTypeCode.PHARMACY,
                    appointment_type="string",
                    end_date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    subscriber_primary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    subscriber_secondary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    additional_information="string",
                    service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                    admission_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    discharge_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    last_menstrual_period_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    delay_reason_code=DelayReasonCode.C_1,
                    patient=PatientUpdate(),
                    patient_authorized_release=True,
                    schema_instances=[],
                    vitals=VitalsUpdate(
                        height_in=70,
                        weight_lbs=165,
                        blood_pressure_systolic_mmhg=115,
                        blood_pressure_diastolic_mmhg=85,
                        body_temperature_f=98.0,
                        hemoglobin_gdl=15.1,
                        hematocrit_pct=51.2,
                    ),
                    existing_medications=[],
                    rendering_provider=RenderingProviderUpdate(),
                    service_facility=EncounterServiceFacilityUpdate(
                        organization_name="Test Organization",
                        address=StreetAddressLongZip(
                            address_1="123 Main St",
                            address_2="Apt 1",
                            city="New York",
                            state=State.NY,
                            zip_code="10001",
                            zip_plus_four_code="1234",
                        ),
                    ),
                    guarantor=GuarantorUpdate(),
                    billing_provider=BillingProviderUpdate(),
                    supervising_provider=SupervisingProviderUpdate(),
                    referring_provider=ReferringProviderUpdate(),
                    initial_referring_provider=InitialReferringProviderUpdate(),
                    referral_number="string",
                ),
                charge_external_id="string",
                ehr_source_url="string",
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                patient_external_id="string",
                status=ChargeCaptureStatus.PLANNED,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "date_of_service": date_of_service,
                "patient_external_id": patient_external_id,
                "status": status,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapture, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic_v1.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    pydantic_v1.parse_obj_as(UnauthorizedErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    pydantic_v1.parse_obj_as(typing.List[RequestValidationError], _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    pydantic_v1.parse_obj_as(SchemaInstanceValidationFailure, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(UnprocessableEntityErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio
        import uuid

        from candid.client import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.delete(
                charge_capture_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic_v1.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    pydantic_v1.parse_obj_as(UnauthorizedErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        charge_capture_id: ChargeCaptureId,
        *,
        data: typing.Optional[ChargeCaptureData] = OMIT,
        charge_external_id: typing.Optional[str] = OMIT,
        ehr_source_url: typing.Optional[str] = OMIT,
        patient_external_id: typing.Optional[str] = OMIT,
        status: typing.Optional[ChargeCaptureStatus] = OMIT,
        date_of_service: typing.Optional[dt.date] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        data : typing.Optional[ChargeCaptureData]

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.


        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page).
            Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge capture

        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import asyncio
        import datetime
        import uuid

        from candid import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EncounterServiceFacilityUpdate,
            FacilityTypeCode,
            Gender,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            PatientUpdate,
            State,
            StreetAddressLongZip,
            SubscriberCreate,
        )
        from candid.client import AsyncCandidApiClient
        from candid.resources.charge_capture.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.encounter_providers.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.v_4 import (
            BillableStatusType,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.v_1 import GuarantorUpdate
        from candid.resources.insurance_cards.v_2 import InsuranceCardCreate

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.update(
                charge_capture_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                data=ChargeCaptureData(
                    diagnoses=[],
                    interventions=[],
                    external_claim_submission=ExternalClaimSubmissionCreate(
                        claim_created_at=datetime.datetime.fromisoformat(
                            "2023-01-01 12:00:00+00:00",
                        ),
                        patient_control_number="PATIENT_CONTROL_NUMBER",
                        submission_records=[
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-01 13:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                            ),
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-04 12:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.PAPER,
                            ),
                        ],
                    ),
                    service_lines=[],
                    patient_histories=[],
                    billing_notes=[],
                    benefits_assigned_to_provider=True,
                    prior_authorization_number="string",
                    external_id="string",
                    date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    tag_ids=[],
                    clinical_notes=[],
                    pay_to_address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                    billable_status=BillableStatusType.BILLABLE,
                    responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                    provider_accepts_assignment=True,
                    synchronicity=SynchronicityType.SYNCHRONOUS,
                    place_of_service_code=FacilityTypeCode.PHARMACY,
                    appointment_type="string",
                    end_date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    subscriber_primary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    subscriber_secondary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    additional_information="string",
                    service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                    admission_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    discharge_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    last_menstrual_period_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    delay_reason_code=DelayReasonCode.C_1,
                    patient=PatientUpdate(),
                    patient_authorized_release=True,
                    schema_instances=[],
                    vitals=VitalsUpdate(
                        height_in=70,
                        weight_lbs=165,
                        blood_pressure_systolic_mmhg=115,
                        blood_pressure_diastolic_mmhg=85,
                        body_temperature_f=98.0,
                        hemoglobin_gdl=15.1,
                        hematocrit_pct=51.2,
                    ),
                    existing_medications=[],
                    rendering_provider=RenderingProviderUpdate(),
                    service_facility=EncounterServiceFacilityUpdate(
                        organization_name="Test Organization",
                        address=StreetAddressLongZip(
                            address_1="123 Main St",
                            address_2="Apt 1",
                            city="New York",
                            state=State.NY,
                            zip_code="10001",
                            zip_plus_four_code="1234",
                        ),
                    ),
                    guarantor=GuarantorUpdate(),
                    billing_provider=BillingProviderUpdate(),
                    supervising_provider=SupervisingProviderUpdate(),
                    referring_provider=ReferringProviderUpdate(),
                    initial_referring_provider=InitialReferringProviderUpdate(),
                    referral_number="string",
                ),
                charge_external_id="string",
                ehr_source_url="string",
                patient_external_id="string",
                status=ChargeCaptureStatus.PLANNED,
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "patient_external_id": patient_external_id,
                "status": status,
                "date_of_service": date_of_service,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapture, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic_v1.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    pydantic_v1.parse_obj_as(UnauthorizedErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    pydantic_v1.parse_obj_as(typing.List[RequestValidationError], _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    pydantic_v1.parse_obj_as(SchemaInstanceValidationFailure, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(UnprocessableEntityErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import asyncio
        import uuid

        from candid.client import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.get(
                charge_capture_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapture, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        page_token: typing.Optional[PageToken] = None,
        patient_external_id: typing.Optional[str] = None,
        status: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id: typing.Optional[str] = None,
        date_of_service: typing.Optional[dt.date] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapturePage:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        page_token : typing.Optional[PageToken]

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge captures

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapturePage

        Examples
        --------
        import asyncio
        import datetime

        from candid.client import AsyncCandidApiClient
        from candid.resources.charge_capture.v_1 import ChargeCaptureStatus

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.get_all(
                limit=1,
                page_token="eyJ0b2tlbiI6IjEiLCJwYWdlX3Rva2VuIjoiMiJ9",
                patient_external_id="string",
                status=ChargeCaptureStatus.PLANNED,
                charge_external_id="string",
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "page_token": page_token,
                "patient_external_id": patient_external_id,
                "status": status,
                "charge_external_id": charge_external_id,
                "date_of_service": str(date_of_service) if date_of_service is not None else None,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ChargeCapturePage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)
