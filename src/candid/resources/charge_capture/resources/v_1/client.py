# This file was auto-generated by Fern from our API Definition.

import typing
from .....core.client_wrapper import SyncClientWrapper
from .types.charge_capture_data import ChargeCaptureData
from .types.charge_capture_status import ChargeCaptureStatus
from .....core.request_options import RequestOptions
from .types.charge_capture import ChargeCapture
from json.decoder import JSONDecodeError
from .....core.api_error import ApiError
from .....core.pydantic_utilities import parse_obj_as
from ....commons.errors.entity_not_found_error import EntityNotFoundError
from ....commons.types.entity_not_found_error_message import EntityNotFoundErrorMessage
from ....commons.errors.unauthorized_error import UnauthorizedError
from ....commons.types.unauthorized_error_message import UnauthorizedErrorMessage
from ....commons.errors.http_request_validations_error import HttpRequestValidationsError
from ....commons.types.request_validation_error import RequestValidationError
from ....encounters.resources.v_4.errors.schema_instance_validation_http_failure import (
    SchemaInstanceValidationHttpFailure,
)
from ....encounters.resources.v_4.types.schema_instance_validation_failure import SchemaInstanceValidationFailure
from ....commons.errors.unprocessable_entity_error import UnprocessableEntityError
from ....commons.types.unprocessable_entity_error_message import UnprocessableEntityErrorMessage
from ....commons.types.charge_capture_id import ChargeCaptureId
from .....core.jsonable_encoder import jsonable_encoder
from .types.charge_capture_sort_field import ChargeCaptureSortField
from ....commons.types.sort_direction import SortDirection
from ....commons.types.page_token import PageToken
import datetime as dt
from ....commons.types.encounter_id import EncounterId
from ....commons.types.charge_capture_claim_creation_id import ChargeCaptureClaimCreationId
from .types.charge_capture_page import ChargeCapturePage
from ....commons.types.charge_capture_post_billed_change_id import ChargeCapturePostBilledChangeId
from .types.charge_capture_post_billed_change import ChargeCapturePostBilledChange
from .....core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class V1Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        *,
        data: ChargeCaptureData,
        charge_external_id: str,
        patient_external_id: str,
        status: ChargeCaptureStatus,
        ehr_source_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        data : ChargeCaptureData
            Charge Capture data contains all the fields needed to create an encounter, but listed as optional. Candid will use this data when attempting to bundle multiple Charge Captures into a single encounter.


        charge_external_id : str
            A client-specified unique ID to associate with this encounter; for example, your internal encounter ID or a Dr. Chrono encounter ID. This field should not contain PHI.


        patient_external_id : str
            The patient ID from the external EMR platform for the patient

        status : ChargeCaptureStatus
            the status of the charge capture

        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page). Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import datetime

        from candid import CandidApiClient
        from candid.resources.charge_capture.resources.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.resources.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.commons import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EpsdtReferralConditionIndicatorCode,
            FacilityTypeCode,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            State,
            StreetAddressLongZip,
        )
        from candid.resources.encounter_providers.resources.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.resources.v_4 import (
            BillableStatusType,
            EpsdtReferral,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.resources.v_1 import GuarantorUpdate
        from candid.resources.individual import Gender, PatientUpdate, SubscriberCreate
        from candid.resources.insurance_cards.resources.v_2 import InsuranceCardCreate
        from candid.resources.service_facility import EncounterServiceFacilityUpdate

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.create(
            data=ChargeCaptureData(
                diagnoses=[],
                interventions=[],
                external_claim_submission=ExternalClaimSubmissionCreate(
                    claim_created_at=datetime.datetime.fromisoformat(
                        "2023-01-01 12:00:00+00:00",
                    ),
                    patient_control_number="PATIENT_CONTROL_NUMBER",
                    submission_records=[
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-01 13:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                        ),
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-04 12:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.PAPER,
                        ),
                    ],
                ),
                service_lines=[],
                patient_histories=[],
                billing_notes=[],
                benefits_assigned_to_provider=True,
                prior_authorization_number="string",
                external_id="string",
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                tag_ids=[],
                clinical_notes=[],
                pay_to_address=StreetAddressLongZip(
                    address_1="123 Main St",
                    address_2="Apt 1",
                    city="New York",
                    state=State.NY,
                    zip_code="10001",
                    zip_plus_four_code="1234",
                ),
                billable_status=BillableStatusType.BILLABLE,
                responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                provider_accepts_assignment=True,
                synchronicity=SynchronicityType.SYNCHRONOUS,
                place_of_service_code=FacilityTypeCode.PHARMACY,
                appointment_type="string",
                end_date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                subscriber_primary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                subscriber_secondary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                subscriber_tertiary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                additional_information="string",
                service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                admission_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                discharge_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                last_menstrual_period_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                delay_reason_code=DelayReasonCode.C_1,
                patient=PatientUpdate(),
                patient_authorized_release=True,
                schema_instances=[],
                vitals=VitalsUpdate(
                    height_in=70,
                    weight_lbs=165,
                    blood_pressure_systolic_mmhg=115,
                    blood_pressure_diastolic_mmhg=85,
                    body_temperature_f=98.0,
                    hemoglobin_gdl=15.1,
                    hematocrit_pct=51.2,
                ),
                existing_medications=[],
                rendering_provider=RenderingProviderUpdate(),
                service_facility=EncounterServiceFacilityUpdate(
                    organization_name="Test Organization",
                    address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                ),
                guarantor=GuarantorUpdate(),
                billing_provider=BillingProviderUpdate(),
                supervising_provider=SupervisingProviderUpdate(),
                referring_provider=ReferringProviderUpdate(),
                initial_referring_provider=InitialReferringProviderUpdate(),
                referral_number="string",
                epsdt_referral=EpsdtReferral(
                    condition_indicator_1=EpsdtReferralConditionIndicatorCode.AV,
                ),
                claim_supplemental_information=[],
            ),
            charge_external_id="string",
            ehr_source_url="string",
            patient_external_id="string",
            status=ChargeCaptureStatus.PLANNED,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "patient_external_id": patient_external_id,
                "status": status,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapture,
                parse_obj_as(
                    type_=ChargeCapture,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    typing.cast(
                        UnprocessableEntityErrorMessage,
                        parse_obj_as(
                            type_=UnprocessableEntityErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.delete(
            charge_capture_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        charge_capture_id: ChargeCaptureId,
        *,
        data: typing.Optional[ChargeCaptureData] = OMIT,
        charge_external_id: typing.Optional[str] = OMIT,
        ehr_source_url: typing.Optional[str] = OMIT,
        patient_external_id: typing.Optional[str] = OMIT,
        status: typing.Optional[ChargeCaptureStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        data : typing.Optional[ChargeCaptureData]

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.


        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page).
            Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge capture

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import datetime
        import uuid

        from candid import CandidApiClient
        from candid.resources.charge_capture.resources.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.resources.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.commons import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EpsdtReferralConditionIndicatorCode,
            FacilityTypeCode,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            State,
            StreetAddressLongZip,
        )
        from candid.resources.encounter_providers.resources.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.resources.v_4 import (
            BillableStatusType,
            EpsdtReferral,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.resources.v_1 import GuarantorUpdate
        from candid.resources.individual import Gender, PatientUpdate, SubscriberCreate
        from candid.resources.insurance_cards.resources.v_2 import InsuranceCardCreate
        from candid.resources.service_facility import EncounterServiceFacilityUpdate

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.update(
            charge_capture_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            data=ChargeCaptureData(
                diagnoses=[],
                interventions=[],
                external_claim_submission=ExternalClaimSubmissionCreate(
                    claim_created_at=datetime.datetime.fromisoformat(
                        "2023-01-01 12:00:00+00:00",
                    ),
                    patient_control_number="PATIENT_CONTROL_NUMBER",
                    submission_records=[
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-01 13:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                        ),
                        ClaimSubmissionRecordCreate(
                            submitted_at=datetime.datetime.fromisoformat(
                                "2023-01-04 12:00:00+00:00",
                            ),
                            claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                            payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                            intended_submission_medium=IntendedSubmissionMedium.PAPER,
                        ),
                    ],
                ),
                service_lines=[],
                patient_histories=[],
                billing_notes=[],
                benefits_assigned_to_provider=True,
                prior_authorization_number="string",
                external_id="string",
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                tag_ids=[],
                clinical_notes=[],
                pay_to_address=StreetAddressLongZip(
                    address_1="123 Main St",
                    address_2="Apt 1",
                    city="New York",
                    state=State.NY,
                    zip_code="10001",
                    zip_plus_four_code="1234",
                ),
                billable_status=BillableStatusType.BILLABLE,
                responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                provider_accepts_assignment=True,
                synchronicity=SynchronicityType.SYNCHRONOUS,
                place_of_service_code=FacilityTypeCode.PHARMACY,
                appointment_type="string",
                end_date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                subscriber_primary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                subscriber_secondary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                subscriber_tertiary=SubscriberCreate(
                    insurance_card=InsuranceCardCreate(
                        member_id="string",
                        payer_name="string",
                        payer_id="string",
                    ),
                    patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                    first_name="string",
                    last_name="string",
                    gender=Gender.MALE,
                ),
                additional_information="string",
                service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                admission_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                discharge_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                last_menstrual_period_date=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                delay_reason_code=DelayReasonCode.C_1,
                patient=PatientUpdate(),
                patient_authorized_release=True,
                schema_instances=[],
                vitals=VitalsUpdate(
                    height_in=70,
                    weight_lbs=165,
                    blood_pressure_systolic_mmhg=115,
                    blood_pressure_diastolic_mmhg=85,
                    body_temperature_f=98.0,
                    hemoglobin_gdl=15.1,
                    hematocrit_pct=51.2,
                ),
                existing_medications=[],
                rendering_provider=RenderingProviderUpdate(),
                service_facility=EncounterServiceFacilityUpdate(
                    organization_name="Test Organization",
                    address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                ),
                guarantor=GuarantorUpdate(),
                billing_provider=BillingProviderUpdate(),
                supervising_provider=SupervisingProviderUpdate(),
                referring_provider=ReferringProviderUpdate(),
                initial_referring_provider=InitialReferringProviderUpdate(),
                referral_number="string",
                epsdt_referral=EpsdtReferral(
                    condition_indicator_1=EpsdtReferralConditionIndicatorCode.AV,
                ),
                claim_supplemental_information=[],
            ),
            charge_external_id="string",
            ehr_source_url="string",
            patient_external_id="string",
            status=ChargeCaptureStatus.PLANNED,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "patient_external_id": patient_external_id,
                "status": status,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapture,
                parse_obj_as(
                    type_=ChargeCapture,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    typing.cast(
                        UnprocessableEntityErrorMessage,
                        parse_obj_as(
                            type_=UnprocessableEntityErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.get(
            charge_capture_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapture,
                parse_obj_as(
                    type_=ChargeCapture,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[ChargeCaptureSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        page_token: typing.Optional[PageToken] = None,
        patient_external_id: typing.Optional[str] = None,
        status: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id: typing.Optional[str] = None,
        date_of_service_min: typing.Optional[dt.date] = None,
        date_of_service_max: typing.Optional[dt.date] = None,
        claim_ids: typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]] = None,
        claim_creation_ids: typing.Optional[
            typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]
        ] = None,
        billing_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        service_facility_name: typing.Optional[str] = None,
        primary_payer_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        exclude_charges_linked_to_claims: typing.Optional[bool] = None,
        patient_external_id_ranked_sort: typing.Optional[str] = None,
        status_ranked_sort: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id_ranked_sort: typing.Optional[str] = None,
        date_of_service_min_ranked_sort: typing.Optional[dt.date] = None,
        date_of_service_max_ranked_sort: typing.Optional[dt.date] = None,
        claim_ids_ranked_sort: typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]] = None,
        claim_creation_ids_ranked_sort: typing.Optional[
            typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]
        ] = None,
        billing_provider_npis_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        service_facility_name_ranked_sort: typing.Optional[str] = None,
        primary_payer_ids_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_npis_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_names_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_npis_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_names_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapturePage:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        sort : typing.Optional[ChargeCaptureSortField]
            Defaults to created_at

        sort_direction : typing.Optional[SortDirection]
            Sort direction. Defaults to descending order if not provided.

        page_token : typing.Optional[PageToken]

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge captures

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service_min : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        date_of_service_max : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        claim_ids : typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]]
            A list of claim IDs to filter by. This will return all charge captures that have a resulting claim with one of the IDs in this list.

        claim_creation_ids : typing.Optional[typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]]
            A list of Claim Creation IDs to filter by.

        billing_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of billing provider NPIs to filter by. This will return all charge captures with one of the NPIs in this list.

        service_facility_name : typing.Optional[str]
            A string to filter by. This will return all charge captures with this service facility name.

        primary_payer_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of primary payer IDs to filter by. This will return all charge captures with one of the primary payer IDs in this list.

        rendering_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider NPIs to filter by. This will return all charge captures with one of the NPIs in this list.

        rendering_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider names to filter by. This will return all charge captures with one of the names in this list.

        supervising_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider NPIs to filter by. This will return all charge captures with one of the NPIs in this list.

        supervising_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider names to filter by. This will return all charge captures with one of the names in this list.

        exclude_charges_linked_to_claims : typing.Optional[bool]
            Whether to exclude charge captures which are part of a claim creation.

        patient_external_id_ranked_sort : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status_ranked_sort : typing.Optional[ChargeCaptureStatus]
            The charge capture status to show first

        charge_external_id_ranked_sort : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service_min_ranked_sort : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        date_of_service_max_ranked_sort : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        claim_ids_ranked_sort : typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]]
            A list of claim IDs to show first. This will return all charge captures that have a resulting claim with one of the IDs in this list.

        claim_creation_ids_ranked_sort : typing.Optional[typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]]
            A list of Claim Creation IDs to show first.

        billing_provider_npis_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of billing provider NPIs to show first. This will return all charge captures with one of the NPIs in this list.

        service_facility_name_ranked_sort : typing.Optional[str]
            A string to show first. This will return all charge captures with this service facility name.

        primary_payer_ids_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of primary payer IDs to show first. This will return all charge captures with one of the primary payer IDs in this list.

        rendering_provider_npis_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider NPIs to show first. This will return all charge captures with one of the NPIs in this list.

        rendering_provider_names_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider names to show first. This will return all charge captures with one of the names in this list.

        supervising_provider_npis_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider NPIs to show first. This will return all charge captures with one of the NPIs in this list.

        supervising_provider_names_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider names to show first. This will return all charge captures with one of the names in this list.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapturePage

        Examples
        --------
        import datetime
        import uuid

        from candid import CandidApiClient
        from candid.resources.charge_capture.resources.v_1 import (
            ChargeCaptureSortField,
            ChargeCaptureStatus,
        )
        from candid.resources.commons import SortDirection

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.get_all(
            limit=1,
            sort=ChargeCaptureSortField.CREATED_AT,
            sort_direction=SortDirection.ASC,
            page_token="eyJ0b2tlbiI6IjEiLCJwYWdlX3Rva2VuIjoiMiJ9",
            patient_external_id="string",
            status=ChargeCaptureStatus.PLANNED,
            charge_external_id="string",
            date_of_service_min=datetime.date.fromisoformat(
                "2023-01-15",
            ),
            date_of_service_max=datetime.date.fromisoformat(
                "2023-01-15",
            ),
            claim_ids=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            claim_creation_ids=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            billing_provider_npis="string",
            service_facility_name="string",
            primary_payer_ids="string",
            rendering_provider_npis="string",
            rendering_provider_names="string",
            supervising_provider_npis="string",
            supervising_provider_names="string",
            exclude_charges_linked_to_claims=True,
            patient_external_id_ranked_sort="string",
            status_ranked_sort=ChargeCaptureStatus.PLANNED,
            charge_external_id_ranked_sort="string",
            date_of_service_min_ranked_sort=datetime.date.fromisoformat(
                "2023-01-15",
            ),
            date_of_service_max_ranked_sort=datetime.date.fromisoformat(
                "2023-01-15",
            ),
            claim_ids_ranked_sort=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            claim_creation_ids_ranked_sort=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            billing_provider_npis_ranked_sort="string",
            service_facility_name_ranked_sort="string",
            primary_payer_ids_ranked_sort="string",
            rendering_provider_npis_ranked_sort="string",
            rendering_provider_names_ranked_sort="string",
            supervising_provider_npis_ranked_sort="string",
            supervising_provider_names_ranked_sort="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "sort": sort,
                "sort_direction": sort_direction,
                "page_token": page_token,
                "patient_external_id": patient_external_id,
                "status": status,
                "charge_external_id": charge_external_id,
                "date_of_service_min": str(date_of_service_min) if date_of_service_min is not None else None,
                "date_of_service_max": str(date_of_service_max) if date_of_service_max is not None else None,
                "claim_ids": claim_ids,
                "claim_creation_ids": claim_creation_ids,
                "billing_provider_npis": billing_provider_npis,
                "service_facility_name": service_facility_name,
                "primary_payer_ids": primary_payer_ids,
                "rendering_provider_npis": rendering_provider_npis,
                "rendering_provider_names": rendering_provider_names,
                "supervising_provider_npis": supervising_provider_npis,
                "supervising_provider_names": supervising_provider_names,
                "exclude_charges_linked_to_claims": exclude_charges_linked_to_claims,
                "patient_external_id_ranked_sort": patient_external_id_ranked_sort,
                "status_ranked_sort": status_ranked_sort,
                "charge_external_id_ranked_sort": charge_external_id_ranked_sort,
                "date_of_service_min_ranked_sort": str(date_of_service_min_ranked_sort)
                if date_of_service_min_ranked_sort is not None
                else None,
                "date_of_service_max_ranked_sort": str(date_of_service_max_ranked_sort)
                if date_of_service_max_ranked_sort is not None
                else None,
                "claim_ids_ranked_sort": claim_ids_ranked_sort,
                "claim_creation_ids_ranked_sort": claim_creation_ids_ranked_sort,
                "billing_provider_npis_ranked_sort": billing_provider_npis_ranked_sort,
                "service_facility_name_ranked_sort": service_facility_name_ranked_sort,
                "primary_payer_ids_ranked_sort": primary_payer_ids_ranked_sort,
                "rendering_provider_npis_ranked_sort": rendering_provider_npis_ranked_sort,
                "rendering_provider_names_ranked_sort": rendering_provider_names_ranked_sort,
                "supervising_provider_npis_ranked_sort": supervising_provider_npis_ranked_sort,
                "supervising_provider_names_ranked_sort": supervising_provider_names_ranked_sort,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapturePage,
                parse_obj_as(
                    type_=ChargeCapturePage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_post_billed_change(
        self,
        charge_capture_change_id: ChargeCapturePostBilledChangeId,
        *,
        resolved: bool,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapturePostBilledChange:
        """
        Parameters
        ----------
        charge_capture_change_id : ChargeCapturePostBilledChangeId

        resolved : bool
            Whether the change has been resolved. If true, the change will be marked as resolved.
            If false, the change will be marked as unresolved.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapturePostBilledChange

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture.v_1.update_post_billed_change(
            charge_capture_change_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            resolved=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/changes/{jsonable_encoder(charge_capture_change_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json={
                "resolved": resolved,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapturePostBilledChange,
                parse_obj_as(
                    type_=ChargeCapturePostBilledChange,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncV1Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        *,
        data: ChargeCaptureData,
        charge_external_id: str,
        patient_external_id: str,
        status: ChargeCaptureStatus,
        ehr_source_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        data : ChargeCaptureData
            Charge Capture data contains all the fields needed to create an encounter, but listed as optional. Candid will use this data when attempting to bundle multiple Charge Captures into a single encounter.


        charge_external_id : str
            A client-specified unique ID to associate with this encounter; for example, your internal encounter ID or a Dr. Chrono encounter ID. This field should not contain PHI.


        patient_external_id : str
            The patient ID from the external EMR platform for the patient

        status : ChargeCaptureStatus
            the status of the charge capture

        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page). Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import asyncio
        import datetime

        from candid import AsyncCandidApiClient
        from candid.resources.charge_capture.resources.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.resources.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.commons import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EpsdtReferralConditionIndicatorCode,
            FacilityTypeCode,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            State,
            StreetAddressLongZip,
        )
        from candid.resources.encounter_providers.resources.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.resources.v_4 import (
            BillableStatusType,
            EpsdtReferral,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.resources.v_1 import GuarantorUpdate
        from candid.resources.individual import Gender, PatientUpdate, SubscriberCreate
        from candid.resources.insurance_cards.resources.v_2 import InsuranceCardCreate
        from candid.resources.service_facility import EncounterServiceFacilityUpdate

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.create(
                data=ChargeCaptureData(
                    diagnoses=[],
                    interventions=[],
                    external_claim_submission=ExternalClaimSubmissionCreate(
                        claim_created_at=datetime.datetime.fromisoformat(
                            "2023-01-01 12:00:00+00:00",
                        ),
                        patient_control_number="PATIENT_CONTROL_NUMBER",
                        submission_records=[
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-01 13:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                            ),
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-04 12:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.PAPER,
                            ),
                        ],
                    ),
                    service_lines=[],
                    patient_histories=[],
                    billing_notes=[],
                    benefits_assigned_to_provider=True,
                    prior_authorization_number="string",
                    external_id="string",
                    date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    tag_ids=[],
                    clinical_notes=[],
                    pay_to_address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                    billable_status=BillableStatusType.BILLABLE,
                    responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                    provider_accepts_assignment=True,
                    synchronicity=SynchronicityType.SYNCHRONOUS,
                    place_of_service_code=FacilityTypeCode.PHARMACY,
                    appointment_type="string",
                    end_date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    subscriber_primary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    subscriber_secondary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    subscriber_tertiary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    additional_information="string",
                    service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                    admission_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    discharge_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    last_menstrual_period_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    delay_reason_code=DelayReasonCode.C_1,
                    patient=PatientUpdate(),
                    patient_authorized_release=True,
                    schema_instances=[],
                    vitals=VitalsUpdate(
                        height_in=70,
                        weight_lbs=165,
                        blood_pressure_systolic_mmhg=115,
                        blood_pressure_diastolic_mmhg=85,
                        body_temperature_f=98.0,
                        hemoglobin_gdl=15.1,
                        hematocrit_pct=51.2,
                    ),
                    existing_medications=[],
                    rendering_provider=RenderingProviderUpdate(),
                    service_facility=EncounterServiceFacilityUpdate(
                        organization_name="Test Organization",
                        address=StreetAddressLongZip(
                            address_1="123 Main St",
                            address_2="Apt 1",
                            city="New York",
                            state=State.NY,
                            zip_code="10001",
                            zip_plus_four_code="1234",
                        ),
                    ),
                    guarantor=GuarantorUpdate(),
                    billing_provider=BillingProviderUpdate(),
                    supervising_provider=SupervisingProviderUpdate(),
                    referring_provider=ReferringProviderUpdate(),
                    initial_referring_provider=InitialReferringProviderUpdate(),
                    referral_number="string",
                    epsdt_referral=EpsdtReferral(
                        condition_indicator_1=EpsdtReferralConditionIndicatorCode.AV,
                    ),
                    claim_supplemental_information=[],
                ),
                charge_external_id="string",
                ehr_source_url="string",
                patient_external_id="string",
                status=ChargeCaptureStatus.PLANNED,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "patient_external_id": patient_external_id,
                "status": status,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapture,
                parse_obj_as(
                    type_=ChargeCapture,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    typing.cast(
                        UnprocessableEntityErrorMessage,
                        parse_obj_as(
                            type_=UnprocessableEntityErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.delete(
                charge_capture_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        charge_capture_id: ChargeCaptureId,
        *,
        data: typing.Optional[ChargeCaptureData] = OMIT,
        charge_external_id: typing.Optional[str] = OMIT,
        ehr_source_url: typing.Optional[str] = OMIT,
        patient_external_id: typing.Optional[str] = OMIT,
        status: typing.Optional[ChargeCaptureStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        data : typing.Optional[ChargeCaptureData]

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.


        ehr_source_url : typing.Optional[str]
            External URL reference that links to Charge Capture details within the external system (e.g. the EHR visit page).
            Send full URL format for the external link (e.g. https://emr_charge_capture_url.com/123).


        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge capture

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import asyncio
        import datetime
        import uuid

        from candid import AsyncCandidApiClient
        from candid.resources.charge_capture.resources.v_1 import (
            ChargeCaptureData,
            ChargeCaptureStatus,
        )
        from candid.resources.claim_submission.resources.v_1 import (
            ClaimFrequencyTypeCode,
            ClaimSubmissionRecordCreate,
            ExternalClaimSubmissionCreate,
        )
        from candid.resources.commons import (
            ClaimSubmissionPayerResponsibilityType,
            DelayReasonCode,
            EpsdtReferralConditionIndicatorCode,
            FacilityTypeCode,
            IntendedSubmissionMedium,
            PatientRelationshipToInsuredCodeAll,
            State,
            StreetAddressLongZip,
        )
        from candid.resources.encounter_providers.resources.v_2 import (
            BillingProviderUpdate,
            InitialReferringProviderUpdate,
            ReferringProviderUpdate,
            RenderingProviderUpdate,
            SupervisingProviderUpdate,
        )
        from candid.resources.encounters.resources.v_4 import (
            BillableStatusType,
            EpsdtReferral,
            ResponsiblePartyType,
            ServiceAuthorizationExceptionCode,
            SynchronicityType,
            VitalsUpdate,
        )
        from candid.resources.guarantor.resources.v_1 import GuarantorUpdate
        from candid.resources.individual import Gender, PatientUpdate, SubscriberCreate
        from candid.resources.insurance_cards.resources.v_2 import InsuranceCardCreate
        from candid.resources.service_facility import EncounterServiceFacilityUpdate

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.update(
                charge_capture_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                data=ChargeCaptureData(
                    diagnoses=[],
                    interventions=[],
                    external_claim_submission=ExternalClaimSubmissionCreate(
                        claim_created_at=datetime.datetime.fromisoformat(
                            "2023-01-01 12:00:00+00:00",
                        ),
                        patient_control_number="PATIENT_CONTROL_NUMBER",
                        submission_records=[
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-01 13:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.ORIGINAL,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.ELECTRONIC,
                            ),
                            ClaimSubmissionRecordCreate(
                                submitted_at=datetime.datetime.fromisoformat(
                                    "2023-01-04 12:00:00+00:00",
                                ),
                                claim_frequency_code=ClaimFrequencyTypeCode.REPLACEMENT,
                                payer_responsibility=ClaimSubmissionPayerResponsibilityType.PRIMARY,
                                intended_submission_medium=IntendedSubmissionMedium.PAPER,
                            ),
                        ],
                    ),
                    service_lines=[],
                    patient_histories=[],
                    billing_notes=[],
                    benefits_assigned_to_provider=True,
                    prior_authorization_number="string",
                    external_id="string",
                    date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    tag_ids=[],
                    clinical_notes=[],
                    pay_to_address=StreetAddressLongZip(
                        address_1="123 Main St",
                        address_2="Apt 1",
                        city="New York",
                        state=State.NY,
                        zip_code="10001",
                        zip_plus_four_code="1234",
                    ),
                    billable_status=BillableStatusType.BILLABLE,
                    responsible_party=ResponsiblePartyType.INSURANCE_PAY,
                    provider_accepts_assignment=True,
                    synchronicity=SynchronicityType.SYNCHRONOUS,
                    place_of_service_code=FacilityTypeCode.PHARMACY,
                    appointment_type="string",
                    end_date_of_service=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    subscriber_primary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    subscriber_secondary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    subscriber_tertiary=SubscriberCreate(
                        insurance_card=InsuranceCardCreate(
                            member_id="string",
                            payer_name="string",
                            payer_id="string",
                        ),
                        patient_relationship_to_subscriber_code=PatientRelationshipToInsuredCodeAll.SPOUSE,
                        first_name="string",
                        last_name="string",
                        gender=Gender.MALE,
                    ),
                    additional_information="string",
                    service_authorization_exception_code=ServiceAuthorizationExceptionCode.C_1,
                    admission_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    discharge_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    onset_of_current_illness_or_symptom_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    last_menstrual_period_date=datetime.date.fromisoformat(
                        "2023-01-15",
                    ),
                    delay_reason_code=DelayReasonCode.C_1,
                    patient=PatientUpdate(),
                    patient_authorized_release=True,
                    schema_instances=[],
                    vitals=VitalsUpdate(
                        height_in=70,
                        weight_lbs=165,
                        blood_pressure_systolic_mmhg=115,
                        blood_pressure_diastolic_mmhg=85,
                        body_temperature_f=98.0,
                        hemoglobin_gdl=15.1,
                        hematocrit_pct=51.2,
                    ),
                    existing_medications=[],
                    rendering_provider=RenderingProviderUpdate(),
                    service_facility=EncounterServiceFacilityUpdate(
                        organization_name="Test Organization",
                        address=StreetAddressLongZip(
                            address_1="123 Main St",
                            address_2="Apt 1",
                            city="New York",
                            state=State.NY,
                            zip_code="10001",
                            zip_plus_four_code="1234",
                        ),
                    ),
                    guarantor=GuarantorUpdate(),
                    billing_provider=BillingProviderUpdate(),
                    supervising_provider=SupervisingProviderUpdate(),
                    referring_provider=ReferringProviderUpdate(),
                    initial_referring_provider=InitialReferringProviderUpdate(),
                    referral_number="string",
                    epsdt_referral=EpsdtReferral(
                        condition_indicator_1=EpsdtReferralConditionIndicatorCode.AV,
                    ),
                    claim_supplemental_information=[],
                ),
                charge_external_id="string",
                ehr_source_url="string",
                patient_external_id="string",
                status=ChargeCaptureStatus.PLANNED,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json={
                "data": data,
                "charge_external_id": charge_external_id,
                "ehr_source_url": ehr_source_url,
                "patient_external_id": patient_external_id,
                "status": status,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapture,
                parse_obj_as(
                    type_=ChargeCapture,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "HttpRequestValidationsError":
                raise HttpRequestValidationsError(
                    typing.cast(
                        typing.List[RequestValidationError],
                        parse_obj_as(
                            type_=typing.List[RequestValidationError],  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "SchemaInstanceValidationHttpFailure":
                raise SchemaInstanceValidationHttpFailure(
                    typing.cast(
                        SchemaInstanceValidationFailure,
                        parse_obj_as(
                            type_=SchemaInstanceValidationFailure,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnprocessableEntityError":
                raise UnprocessableEntityError(
                    typing.cast(
                        UnprocessableEntityErrorMessage,
                        parse_obj_as(
                            type_=UnprocessableEntityErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, charge_capture_id: ChargeCaptureId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ChargeCapture:
        """
        Parameters
        ----------
        charge_capture_id : ChargeCaptureId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapture

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.get(
                charge_capture_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/{jsonable_encoder(charge_capture_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapture,
                parse_obj_as(
                    type_=ChargeCapture,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[ChargeCaptureSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        page_token: typing.Optional[PageToken] = None,
        patient_external_id: typing.Optional[str] = None,
        status: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id: typing.Optional[str] = None,
        date_of_service_min: typing.Optional[dt.date] = None,
        date_of_service_max: typing.Optional[dt.date] = None,
        claim_ids: typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]] = None,
        claim_creation_ids: typing.Optional[
            typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]
        ] = None,
        billing_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        service_facility_name: typing.Optional[str] = None,
        primary_payer_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        exclude_charges_linked_to_claims: typing.Optional[bool] = None,
        patient_external_id_ranked_sort: typing.Optional[str] = None,
        status_ranked_sort: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id_ranked_sort: typing.Optional[str] = None,
        date_of_service_min_ranked_sort: typing.Optional[dt.date] = None,
        date_of_service_max_ranked_sort: typing.Optional[dt.date] = None,
        claim_ids_ranked_sort: typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]] = None,
        claim_creation_ids_ranked_sort: typing.Optional[
            typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]
        ] = None,
        billing_provider_npis_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        service_facility_name_ranked_sort: typing.Optional[str] = None,
        primary_payer_ids_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_npis_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_names_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_npis_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_names_ranked_sort: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapturePage:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        sort : typing.Optional[ChargeCaptureSortField]
            Defaults to created_at

        sort_direction : typing.Optional[SortDirection]
            Sort direction. Defaults to descending order if not provided.

        page_token : typing.Optional[PageToken]

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status : typing.Optional[ChargeCaptureStatus]
            the status of the charge captures

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service_min : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        date_of_service_max : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        claim_ids : typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]]
            A list of claim IDs to filter by. This will return all charge captures that have a resulting claim with one of the IDs in this list.

        claim_creation_ids : typing.Optional[typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]]
            A list of Claim Creation IDs to filter by.

        billing_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of billing provider NPIs to filter by. This will return all charge captures with one of the NPIs in this list.

        service_facility_name : typing.Optional[str]
            A string to filter by. This will return all charge captures with this service facility name.

        primary_payer_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of primary payer IDs to filter by. This will return all charge captures with one of the primary payer IDs in this list.

        rendering_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider NPIs to filter by. This will return all charge captures with one of the NPIs in this list.

        rendering_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider names to filter by. This will return all charge captures with one of the names in this list.

        supervising_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider NPIs to filter by. This will return all charge captures with one of the NPIs in this list.

        supervising_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider names to filter by. This will return all charge captures with one of the names in this list.

        exclude_charges_linked_to_claims : typing.Optional[bool]
            Whether to exclude charge captures which are part of a claim creation.

        patient_external_id_ranked_sort : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        status_ranked_sort : typing.Optional[ChargeCaptureStatus]
            The charge capture status to show first

        charge_external_id_ranked_sort : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service_min_ranked_sort : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        date_of_service_max_ranked_sort : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        claim_ids_ranked_sort : typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]]
            A list of claim IDs to show first. This will return all charge captures that have a resulting claim with one of the IDs in this list.

        claim_creation_ids_ranked_sort : typing.Optional[typing.Union[ChargeCaptureClaimCreationId, typing.Sequence[ChargeCaptureClaimCreationId]]]
            A list of Claim Creation IDs to show first.

        billing_provider_npis_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of billing provider NPIs to show first. This will return all charge captures with one of the NPIs in this list.

        service_facility_name_ranked_sort : typing.Optional[str]
            A string to show first. This will return all charge captures with this service facility name.

        primary_payer_ids_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of primary payer IDs to show first. This will return all charge captures with one of the primary payer IDs in this list.

        rendering_provider_npis_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider NPIs to show first. This will return all charge captures with one of the NPIs in this list.

        rendering_provider_names_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider names to show first. This will return all charge captures with one of the names in this list.

        supervising_provider_npis_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider NPIs to show first. This will return all charge captures with one of the NPIs in this list.

        supervising_provider_names_ranked_sort : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider names to show first. This will return all charge captures with one of the names in this list.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapturePage

        Examples
        --------
        import asyncio
        import datetime
        import uuid

        from candid import AsyncCandidApiClient
        from candid.resources.charge_capture.resources.v_1 import (
            ChargeCaptureSortField,
            ChargeCaptureStatus,
        )
        from candid.resources.commons import SortDirection

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.get_all(
                limit=1,
                sort=ChargeCaptureSortField.CREATED_AT,
                sort_direction=SortDirection.ASC,
                page_token="eyJ0b2tlbiI6IjEiLCJwYWdlX3Rva2VuIjoiMiJ9",
                patient_external_id="string",
                status=ChargeCaptureStatus.PLANNED,
                charge_external_id="string",
                date_of_service_min=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                date_of_service_max=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                claim_ids=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                claim_creation_ids=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                billing_provider_npis="string",
                service_facility_name="string",
                primary_payer_ids="string",
                rendering_provider_npis="string",
                rendering_provider_names="string",
                supervising_provider_npis="string",
                supervising_provider_names="string",
                exclude_charges_linked_to_claims=True,
                patient_external_id_ranked_sort="string",
                status_ranked_sort=ChargeCaptureStatus.PLANNED,
                charge_external_id_ranked_sort="string",
                date_of_service_min_ranked_sort=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                date_of_service_max_ranked_sort=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                claim_ids_ranked_sort=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                claim_creation_ids_ranked_sort=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                billing_provider_npis_ranked_sort="string",
                service_facility_name_ranked_sort="string",
                primary_payer_ids_ranked_sort="string",
                rendering_provider_npis_ranked_sort="string",
                rendering_provider_names_ranked_sort="string",
                supervising_provider_npis_ranked_sort="string",
                supervising_provider_names_ranked_sort="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/charge_captures/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "sort": sort,
                "sort_direction": sort_direction,
                "page_token": page_token,
                "patient_external_id": patient_external_id,
                "status": status,
                "charge_external_id": charge_external_id,
                "date_of_service_min": str(date_of_service_min) if date_of_service_min is not None else None,
                "date_of_service_max": str(date_of_service_max) if date_of_service_max is not None else None,
                "claim_ids": claim_ids,
                "claim_creation_ids": claim_creation_ids,
                "billing_provider_npis": billing_provider_npis,
                "service_facility_name": service_facility_name,
                "primary_payer_ids": primary_payer_ids,
                "rendering_provider_npis": rendering_provider_npis,
                "rendering_provider_names": rendering_provider_names,
                "supervising_provider_npis": supervising_provider_npis,
                "supervising_provider_names": supervising_provider_names,
                "exclude_charges_linked_to_claims": exclude_charges_linked_to_claims,
                "patient_external_id_ranked_sort": patient_external_id_ranked_sort,
                "status_ranked_sort": status_ranked_sort,
                "charge_external_id_ranked_sort": charge_external_id_ranked_sort,
                "date_of_service_min_ranked_sort": str(date_of_service_min_ranked_sort)
                if date_of_service_min_ranked_sort is not None
                else None,
                "date_of_service_max_ranked_sort": str(date_of_service_max_ranked_sort)
                if date_of_service_max_ranked_sort is not None
                else None,
                "claim_ids_ranked_sort": claim_ids_ranked_sort,
                "claim_creation_ids_ranked_sort": claim_creation_ids_ranked_sort,
                "billing_provider_npis_ranked_sort": billing_provider_npis_ranked_sort,
                "service_facility_name_ranked_sort": service_facility_name_ranked_sort,
                "primary_payer_ids_ranked_sort": primary_payer_ids_ranked_sort,
                "rendering_provider_npis_ranked_sort": rendering_provider_npis_ranked_sort,
                "rendering_provider_names_ranked_sort": rendering_provider_names_ranked_sort,
                "supervising_provider_npis_ranked_sort": supervising_provider_npis_ranked_sort,
                "supervising_provider_names_ranked_sort": supervising_provider_names_ranked_sort,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapturePage,
                parse_obj_as(
                    type_=ChargeCapturePage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_post_billed_change(
        self,
        charge_capture_change_id: ChargeCapturePostBilledChangeId,
        *,
        resolved: bool,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCapturePostBilledChange:
        """
        Parameters
        ----------
        charge_capture_change_id : ChargeCapturePostBilledChangeId

        resolved : bool
            Whether the change has been resolved. If true, the change will be marked as resolved.
            If false, the change will be marked as unresolved.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCapturePostBilledChange

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture.v_1.update_post_billed_change(
                charge_capture_change_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                resolved=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_captures/v1/changes/{jsonable_encoder(charge_capture_change_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="PATCH",
            json={
                "resolved": resolved,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCapturePostBilledChange,
                parse_obj_as(
                    type_=ChargeCapturePostBilledChange,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    typing.cast(
                        EntityNotFoundErrorMessage,
                        parse_obj_as(
                            type_=EntityNotFoundErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
            if _response_json["errorName"] == "UnauthorizedError":
                raise UnauthorizedError(
                    typing.cast(
                        UnauthorizedErrorMessage,
                        parse_obj_as(
                            type_=UnauthorizedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)
