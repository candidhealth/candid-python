# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ......core.datetime_utils import serialize_datetime
from ......core.pydantic_utilities import deep_union_pydantic_dicts
from .....charge_capture.resources.v_1.types.charge_capture import ChargeCapture
from .....commons.types.charge_capture_bundle_id import ChargeCaptureBundleId
from .....commons.types.encounter_id import EncounterId
from .charge_bundle_error import ChargeBundleError
from .charge_capture_bundle_status import ChargeCaptureBundleStatus


class ChargeCaptureBundle(pydantic.BaseModel):
    id: ChargeCaptureBundleId
    created_encounter_id: typing.Optional[EncounterId] = None
    status: ChargeCaptureBundleStatus = pydantic.Field()
    """
    Status of the Bundle, Successful means that the Bundle created a corresponding Claim
    """

    charge_captures: typing.List[ChargeCapture] = pydantic.Field()
    """
    All the underlying ChargeCaptures that are present in a ChargeCaptureBundle.
    """

    errors: typing.List[ChargeBundleError] = pydantic.Field()
    """
    All errors that were found when the bundle was attempted to be created.
    Errors can correspond to the Bundle as a whole or specific underlying Charge Captures.
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        extra = pydantic.Extra.allow
        json_encoders = {dt.datetime: serialize_datetime}
