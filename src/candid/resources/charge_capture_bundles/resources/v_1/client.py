# This file was auto-generated by Fern from our API Definition.

from .....core.client_wrapper import SyncClientWrapper
from ....commons.types.charge_capture_bundle_id import ChargeCaptureBundleId
import typing
from .....core.request_options import RequestOptions
from .types.charge_capture_bundle import ChargeCaptureBundle
from .....core.jsonable_encoder import jsonable_encoder
from json.decoder import JSONDecodeError
from .....core.api_error import ApiError
from .....core.pydantic_utilities import parse_obj_as
from .types.charge_capture_bundle_summary import ChargeCaptureBundleSummary
from ....commons.errors.not_implemented_error import NotImplementedError
from ....commons.types.not_implemented_error_message import NotImplementedErrorMessage
from .types.charge_capture_bundle_sort_field import ChargeCaptureBundleSortField
from ....commons.types.sort_direction import SortDirection
from ....commons.types.page_token import PageToken
from .types.charge_capture_bundle_status import ChargeCaptureBundleStatus
from ....charge_capture.resources.v_1.types.charge_capture_status import ChargeCaptureStatus
import datetime as dt
from ....commons.types.encounter_id import EncounterId
from .types.charge_capture_bundle_page import ChargeCaptureBundlePage
from .....core.client_wrapper import AsyncClientWrapper


class V1Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        charge_capture_bundle_id: ChargeCaptureBundleId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCaptureBundle:
        """
        Parameters
        ----------
        charge_capture_bundle_id : ChargeCaptureBundleId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundle

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture_bundles.v_1.get(
            charge_capture_bundle_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_capture_bundle/v1/{jsonable_encoder(charge_capture_bundle_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundle,
                parse_obj_as(
                    type_=ChargeCaptureBundle,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_summary(self, *, request_options: typing.Optional[RequestOptions] = None) -> ChargeCaptureBundleSummary:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundleSummary

        Examples
        --------
        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture_bundles.v_1.get_summary()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/charge_capture_bundle/v1/all/summary",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundleSummary,
                parse_obj_as(
                    type_=ChargeCaptureBundleSummary,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def resubmit(
        self,
        charge_capture_bundle_id: ChargeCaptureBundleId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCaptureBundle:
        """
        Parameters
        ----------
        charge_capture_bundle_id : ChargeCaptureBundleId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundle

        Examples
        --------
        import uuid

        from candid import CandidApiClient

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture_bundles.v_1.resubmit(
            charge_capture_bundle_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/charge_capture_bundle/v1/{jsonable_encoder(charge_capture_bundle_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundle,
                parse_obj_as(
                    type_=ChargeCaptureBundle,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "NotImplementedError":
                raise NotImplementedError(
                    typing.cast(
                        NotImplementedErrorMessage,
                        parse_obj_as(
                            type_=NotImplementedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[ChargeCaptureBundleSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        page_token: typing.Optional[PageToken] = None,
        patient_external_id: typing.Optional[str] = None,
        bundle_status: typing.Optional[ChargeCaptureBundleStatus] = None,
        charge_status: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id: typing.Optional[str] = None,
        date_of_service: typing.Optional[dt.date] = None,
        claim_ids: typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]] = None,
        bundle_ids: typing.Optional[typing.Union[ChargeCaptureBundleId, typing.Sequence[ChargeCaptureBundleId]]] = None,
        billing_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        service_facility_name: typing.Optional[str] = None,
        primary_payer_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        has_charge_capture_updates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCaptureBundlePage:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        sort : typing.Optional[ChargeCaptureBundleSortField]
            Defaults to created_at

        sort_direction : typing.Optional[SortDirection]
            Sort direction. Defaults to descending order if not provided.

        page_token : typing.Optional[PageToken]

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        bundle_status : typing.Optional[ChargeCaptureBundleStatus]
            the status of the charge capture bundle, refers to whether it was able to create an encounter.

        charge_status : typing.Optional[ChargeCaptureStatus]
            the status of the charge captures

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        claim_ids : typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]]
            A list of claim IDs to filter by. This will return all charge capture bundles that have a resulting claim with one of the IDs in this list.

        bundle_ids : typing.Optional[typing.Union[ChargeCaptureBundleId, typing.Sequence[ChargeCaptureBundleId]]]
            A list of bundle IDs to filter by.

        billing_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of billing provider NPIs to filter by. This will return all charge capture bundles which include one or more charges with one of the NPIs in this list.

        service_facility_name : typing.Optional[str]
            A string to filter by. This will return all charge capture bundles which include one or more charges with this service facility name.

        primary_payer_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of primary payer IDs to filter by. This will return all charge capture bundles which include one or more charges with one of the primary payer IDs in this list.

        rendering_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider NPIs to filter by. This will return all charge capture bundles which include one or more charges with one of the NPIs in this list.

        rendering_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider names to filter by. This will return all charge capture bundles which include one or more charges with one of the names in this list.

        supervising_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider NPIs to filter by. This will return all charge capture bundles which include one or more charges with one of the NPIs in this list.

        supervising_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider names to filter by. This will return all charge capture bundles which include one or more charges with one of the names in this list.

        has_charge_capture_updates : typing.Optional[bool]
            If true, only return bundles that have charge captures that have been updated since the bundle has had a status of BILLED. See the updates property on ChargeCapture for more details.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundlePage

        Examples
        --------
        import datetime
        import uuid

        from candid import CandidApiClient
        from candid.resources.charge_capture.resources.v_1 import ChargeCaptureStatus
        from candid.resources.charge_capture_bundles.resources.v_1 import (
            ChargeCaptureBundleSortField,
            ChargeCaptureBundleStatus,
        )
        from candid.resources.commons import SortDirection

        client = CandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.charge_capture_bundles.v_1.get_all(
            limit=1,
            sort=ChargeCaptureBundleSortField.CREATED_AT,
            sort_direction=SortDirection.ASC,
            page_token="eyJ0b2tlbiI6IjEiLCJwYWdlX3Rva2VuIjoiMiJ9",
            patient_external_id="string",
            bundle_status=ChargeCaptureBundleStatus.NOT_STARTED,
            charge_status=ChargeCaptureStatus.PLANNED,
            charge_external_id="string",
            date_of_service=datetime.date.fromisoformat(
                "2023-01-15",
            ),
            claim_ids=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            bundle_ids=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
            billing_provider_npis="string",
            service_facility_name="string",
            primary_payer_ids="string",
            rendering_provider_npis="string",
            rendering_provider_names="string",
            supervising_provider_npis="string",
            supervising_provider_names="string",
            has_charge_capture_updates=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/charge_capture_bundle/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "sort": sort,
                "sort_direction": sort_direction,
                "page_token": page_token,
                "patient_external_id": patient_external_id,
                "bundle_status": bundle_status,
                "charge_status": charge_status,
                "charge_external_id": charge_external_id,
                "date_of_service": str(date_of_service) if date_of_service is not None else None,
                "claim_ids": claim_ids,
                "bundle_ids": bundle_ids,
                "billing_provider_npis": billing_provider_npis,
                "service_facility_name": service_facility_name,
                "primary_payer_ids": primary_payer_ids,
                "rendering_provider_npis": rendering_provider_npis,
                "rendering_provider_names": rendering_provider_names,
                "supervising_provider_npis": supervising_provider_npis,
                "supervising_provider_names": supervising_provider_names,
                "has_charge_capture_updates": has_charge_capture_updates,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundlePage,
                parse_obj_as(
                    type_=ChargeCaptureBundlePage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncV1Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        charge_capture_bundle_id: ChargeCaptureBundleId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCaptureBundle:
        """
        Parameters
        ----------
        charge_capture_bundle_id : ChargeCaptureBundleId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundle

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture_bundles.v_1.get(
                charge_capture_bundle_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_capture_bundle/v1/{jsonable_encoder(charge_capture_bundle_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundle,
                parse_obj_as(
                    type_=ChargeCaptureBundle,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_summary(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ChargeCaptureBundleSummary:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundleSummary

        Examples
        --------
        import asyncio

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture_bundles.v_1.get_summary()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/charge_capture_bundle/v1/all/summary",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundleSummary,
                parse_obj_as(
                    type_=ChargeCaptureBundleSummary,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def resubmit(
        self,
        charge_capture_bundle_id: ChargeCaptureBundleId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCaptureBundle:
        """
        Parameters
        ----------
        charge_capture_bundle_id : ChargeCaptureBundleId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundle

        Examples
        --------
        import asyncio
        import uuid

        from candid import AsyncCandidApiClient

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture_bundles.v_1.resubmit(
                charge_capture_bundle_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/charge_capture_bundle/v1/{jsonable_encoder(charge_capture_bundle_id)}",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="POST",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundle,
                parse_obj_as(
                    type_=ChargeCaptureBundle,  # type: ignore
                    object_=_response_json,
                ),
            )
        if "errorName" in _response_json:
            if _response_json["errorName"] == "NotImplementedError":
                raise NotImplementedError(
                    typing.cast(
                        NotImplementedErrorMessage,
                        parse_obj_as(
                            type_=NotImplementedErrorMessage,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    )
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_all(
        self,
        *,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[ChargeCaptureBundleSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        page_token: typing.Optional[PageToken] = None,
        patient_external_id: typing.Optional[str] = None,
        bundle_status: typing.Optional[ChargeCaptureBundleStatus] = None,
        charge_status: typing.Optional[ChargeCaptureStatus] = None,
        charge_external_id: typing.Optional[str] = None,
        date_of_service: typing.Optional[dt.date] = None,
        claim_ids: typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]] = None,
        bundle_ids: typing.Optional[typing.Union[ChargeCaptureBundleId, typing.Sequence[ChargeCaptureBundleId]]] = None,
        billing_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        service_facility_name: typing.Optional[str] = None,
        primary_payer_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        rendering_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_npis: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        supervising_provider_names: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        has_charge_capture_updates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChargeCaptureBundlePage:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Maximum number of entities per page, defaults to 100.

        sort : typing.Optional[ChargeCaptureBundleSortField]
            Defaults to created_at

        sort_direction : typing.Optional[SortDirection]
            Sort direction. Defaults to descending order if not provided.

        page_token : typing.Optional[PageToken]

        patient_external_id : typing.Optional[str]
            The patient ID from the external EMR platform for the patient

        bundle_status : typing.Optional[ChargeCaptureBundleStatus]
            the status of the charge capture bundle, refers to whether it was able to create an encounter.

        charge_status : typing.Optional[ChargeCaptureStatus]
            the status of the charge captures

        charge_external_id : typing.Optional[str]
            A client-specified unique ID to associate with this encounter;
            for example, your internal encounter ID or a Dr. Chrono encounter ID.
            This field should not contain PHI.

        date_of_service : typing.Optional[dt.date]
            Date formatted as YYYY-MM-DD; eg: 2019-08-24.
            This date must be the local date in the timezone where the service occurred.

        claim_ids : typing.Optional[typing.Union[EncounterId, typing.Sequence[EncounterId]]]
            A list of claim IDs to filter by. This will return all charge capture bundles that have a resulting claim with one of the IDs in this list.

        bundle_ids : typing.Optional[typing.Union[ChargeCaptureBundleId, typing.Sequence[ChargeCaptureBundleId]]]
            A list of bundle IDs to filter by.

        billing_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of billing provider NPIs to filter by. This will return all charge capture bundles which include one or more charges with one of the NPIs in this list.

        service_facility_name : typing.Optional[str]
            A string to filter by. This will return all charge capture bundles which include one or more charges with this service facility name.

        primary_payer_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of primary payer IDs to filter by. This will return all charge capture bundles which include one or more charges with one of the primary payer IDs in this list.

        rendering_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider NPIs to filter by. This will return all charge capture bundles which include one or more charges with one of the NPIs in this list.

        rendering_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of rendering provider names to filter by. This will return all charge capture bundles which include one or more charges with one of the names in this list.

        supervising_provider_npis : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider NPIs to filter by. This will return all charge capture bundles which include one or more charges with one of the NPIs in this list.

        supervising_provider_names : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of supervising provider names to filter by. This will return all charge capture bundles which include one or more charges with one of the names in this list.

        has_charge_capture_updates : typing.Optional[bool]
            If true, only return bundles that have charge captures that have been updated since the bundle has had a status of BILLED. See the updates property on ChargeCapture for more details.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChargeCaptureBundlePage

        Examples
        --------
        import asyncio
        import datetime
        import uuid

        from candid import AsyncCandidApiClient
        from candid.resources.charge_capture.resources.v_1 import ChargeCaptureStatus
        from candid.resources.charge_capture_bundles.resources.v_1 import (
            ChargeCaptureBundleSortField,
            ChargeCaptureBundleStatus,
        )
        from candid.resources.commons import SortDirection

        client = AsyncCandidApiClient(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.charge_capture_bundles.v_1.get_all(
                limit=1,
                sort=ChargeCaptureBundleSortField.CREATED_AT,
                sort_direction=SortDirection.ASC,
                page_token="eyJ0b2tlbiI6IjEiLCJwYWdlX3Rva2VuIjoiMiJ9",
                patient_external_id="string",
                bundle_status=ChargeCaptureBundleStatus.NOT_STARTED,
                charge_status=ChargeCaptureStatus.PLANNED,
                charge_external_id="string",
                date_of_service=datetime.date.fromisoformat(
                    "2023-01-15",
                ),
                claim_ids=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                bundle_ids=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
                billing_provider_npis="string",
                service_facility_name="string",
                primary_payer_ids="string",
                rendering_provider_npis="string",
                rendering_provider_names="string",
                supervising_provider_npis="string",
                supervising_provider_names="string",
                has_charge_capture_updates=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/charge_capture_bundle/v1",
            base_url=self._client_wrapper.get_environment().candid_api,
            method="GET",
            params={
                "limit": limit,
                "sort": sort,
                "sort_direction": sort_direction,
                "page_token": page_token,
                "patient_external_id": patient_external_id,
                "bundle_status": bundle_status,
                "charge_status": charge_status,
                "charge_external_id": charge_external_id,
                "date_of_service": str(date_of_service) if date_of_service is not None else None,
                "claim_ids": claim_ids,
                "bundle_ids": bundle_ids,
                "billing_provider_npis": billing_provider_npis,
                "service_facility_name": service_facility_name,
                "primary_payer_ids": primary_payer_ids,
                "rendering_provider_npis": rendering_provider_npis,
                "rendering_provider_names": rendering_provider_names,
                "supervising_provider_npis": supervising_provider_npis,
                "supervising_provider_names": supervising_provider_names,
                "has_charge_capture_updates": has_charge_capture_updates,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                ChargeCaptureBundlePage,
                parse_obj_as(
                    type_=ChargeCaptureBundlePage,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)
