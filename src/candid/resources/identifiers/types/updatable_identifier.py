# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import datetime as dt
import typing

import pydantic

from ....core.datetime_utils import serialize_datetime
from ....core.pydantic_utilities import deep_union_pydantic_dicts
from ...commons.types.date_range_optional_end import DateRangeOptionalEnd
from ...commons.types.removable_date_range_optional_end import RemovableDateRangeOptionalEnd
from .identifier_code import IdentifierCode
from .identifier_id import IdentifierId
from .identifier_value import IdentifierValue


class UpdatableIdentifier_Add(pydantic.BaseModel):
    period: typing.Optional[DateRangeOptionalEnd] = None
    identifier_code: IdentifierCode
    identifier_value: IdentifierValue
    type: typing.Literal["add"] = "add"

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        extra = pydantic.Extra.forbid
        json_encoders = {dt.datetime: serialize_datetime}


class UpdatableIdentifier_Update(pydantic.BaseModel):
    identifier_id: IdentifierId
    identifier_code: typing.Optional[IdentifierCode] = None
    identifier_value: typing.Optional[IdentifierValue] = None
    period: typing.Optional[RemovableDateRangeOptionalEnd] = None
    type: typing.Literal["update"] = "update"

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        extra = pydantic.Extra.forbid
        json_encoders = {dt.datetime: serialize_datetime}


class UpdatableIdentifier_Remove(pydantic.BaseModel):
    value: IdentifierId
    type: typing.Literal["remove"] = "remove"

    class Config:
        frozen = True
        smart_union = True


UpdatableIdentifier = typing.Union[UpdatableIdentifier_Add, UpdatableIdentifier_Update, UpdatableIdentifier_Remove]
